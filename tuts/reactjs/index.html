<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>React</title>
  <link href="../assets/prism.css" type="text/css" rel="stylesheet" media="all" />
  <link href="../assets/styles.css" type="text/css" rel="stylesheet" media="all" />
  <script src="../assets/prism.js"></script>
</head>

<body>
  <nav class="site-nav">
    <ul>
      <li><a href="#reactElement">React Element</a></li>
      <li><a href="#reactLifecycleEvents">Lifecycle Events</a></li>
      <li><a href="#reactHandlingEvents">Handling Events</a></li>
      <li><a href="#reactInstallation">Installation</a></li>
      <li><a href="#jsxIntro">JSX</a></li>
      <li><a href="#componentInDetails">Component</a></li>
      <li><a href="#reactFragment">Fragment</a></li>
      <li><a href="#reactProps">Props</a></li>
      <li><a href="#reactProptypes">Proptypes</a></li>
      <li><a href="#reactState">State</a></li>
      <li><a href="#reactPropsVsState">Props vs State</a></li>
      <li><a href="#reactContextAPI">Context API</a></li>
      <li><a href="#reactRouter">Router</a></li>
      <li><a href="#formHandling">Form Handling</a></li>
    </ul>
  </nav>

  <h2>React Concepts</h2>

  <h3>Declarative</h3>
  <p class="list-heading">It's really not a new concept, but React took building UIs a lot more declaratively than with
    HTML templates:</p>
  <ul>
    <li>you can build Web interfaces without even touching the DOM directly</li>
    <li>you can have an event system without having to interact with the actual DOM Events.</li>
  </ul>
  <p>The opposite of declarative is <strong>iterative.</strong> A common example of an iterative approach is looking up
    elements in the DOM using jQuery or DOM events. You tell the browser exactly what to do, instead of telling it what
    you need.</p>
  <p>The React declarative approach abstracts that for us. We just tell React we want a component to be rendered in a
    specific way, and we never have to interact with the DOM to reference it later.</p>
  
  <h3>Immutability</h3>
  <p>An immutable variable can never be changed. To update its value, you create a new variable. The same applies to
    objects and arrays. Instead of changing an array, to add a new item you create a new array by concatenating the old
    array, plus the new item. An object is never updated, but copied before changing it.</p>
  <p>This applies to React in many places. For example, you should never mutate the state property of a component
    directly, but only through the setState() method.</p>
  <p>In Redux, you never mutate the state directly, but only through reducers, which are functions. </p>
  <ul>
    <li>Mutations can be
      centralized, like in the case of Redux, which improves your
      debugging capabilities and reduces sources of errors.</li>
    <li>Code looks cleaner and simpler to understand. You never expect
      a function to change some value without you knowing, which gives you predictability. When a function does not mutate
      objects but just returns a new object, it's called a pure function.</li>
    <li>library can optimize the code because for
      example JavaScript is faster when swapping an old object reference for an entirely new object, rather than mutating
      an existing object. This gives you performance.</li>
  </ul>

  <h3>Purity</h3>
  <p><strong>What is purity, a pure function and a pure component?</strong></p>
	
  <p>In JavaScript, when a function does not mutate objects but just returns a new object, it's called a pure function.
  </p>
  <p>A function, or a method, in order to be called pure should not cause side effects and should return the same output
    when called multiple times with the same input.</p>
  
  <p>A pure function takes an input and returns an output without changing the input nor anything else. Its output is only
    determined by the arguments.</p>
  <p>React applies this concept to components. A React component is a pure component when its output is only dependant on
    its props.</p>
  <p>All functional components are pure components:</p>
  <pre><code class="language-jsx">
    const Button = props =&#x3E; {
      return &#x3C;button&#x3E;{props.message}&#x3C;/button&#x3E;
    }
  </code></pre>

  <p>Class components can be pure if their output only depends on the props:</p>
  <pre><code class="language-jsx">
    class Button extends React.Component {
      render() {
        return &#x3C;button&#x3E;{this.props.message}&#x3C;/button&#x3E;
      }
    }
  </code></pre>
  <h3>Create specialized version of a component</h3>
  <p>Use an outer component to expand and specialize a more generic component:</p>
  <pre><code class="language-jsx">
    const Button = props =&#x3E; {
      return &#x3C;button&#x3E;{props.text}&#x3C;/button&#x3E;
    }
    
    const SubmitButton = () =&#x3E; {
      return &#x3C;Button text=&#x22;Submit&#x22; /&#x3E;
    }
    
    const LoginButton = () =&#x3E; {
      return &#x3C;Button text=&#x22;Login&#x22; /&#x3E;
    }
  </code></pre>

  <h3>Pass methods as props</h3>
    A component can focus on tracking a click event, for example, and what actually happens when the click event happens is up to the container component:</p>
  <pre><code class="language-js">
      const Button = props =&#x3E; {
        return &#x3C;button onClick={props.onClickHandler}&#x3E;{props.text}&#x3C;/button&#x3E;
      }
      
      const LoginButton = props =&#x3E; {
        return &#x3C;Button text=&#x22;Login&#x22; onClickHandler={props.onClickHandler} /&#x3E;
      }
      
      const Container = () =&#x3E; {
        const onClickHandler = () =&#x3E; {
          alert(&#x27;clicked&#x27;)
        }
      
        return &#x3C;LoginButton onClickHandler={onClickHandler} /&#x3E;
      }
  </code></pre>

  <h3>Using children</h3>
  <p>The props.children property allows you to inject components inside other components.</p>

  <p>The component needs to output props.children in its JSX:</p>
  <pre><code class="language-jsx">
    const Sidebar = props =&#x3E; {
      return &#x3C;aside&#x3E;{props.children}&#x3C;/aside&#x3E;
    }
  </code></pre>
  <p>and you embed more components into it in a transparent way:</p>
  <pre><code class="language-jsx">
    &#x3C;Sidebar&#x3E;
      &#x3C;Link title=&#x22;First link&#x22; /&#x3E;
      &#x3C;Link title=&#x22;Second link&#x22; /&#x3E;
    &#x3C;/Sidebar&#x3E;
  </code></pre>
  
  <h3>Higher order components</h3>
  <p>When a component receives a component as a prop and returns a component, it's called higher order component.</p>

  <h3>Unidirectional Data Flow</h3>
  <p>this concept means that data has one, and only one, way to be transferred to other parts of the application.</p>
  
  <p class="list-heading"><strong>In React this means that:</strong></p>  
  <ul>
    <li>state is passed to the view and to child components</li>
    <li>actions are triggered by the view</li>
    <li>actions can update the state</li>
    <li>the state change is passed to the view and to child components</li>
  </ul>
  <p>The view is a result of the application state. State can only change when actions happen. When actions happen, the state is updated.</p>
  <figure><img src="img/unidirectional-data-flow.jpg" alt="" /></figure>
  <p class="list-heading"><strong>this has some key advantages:</strong></p>  
  <ul>
    <li>it's less error prone, as you have more control over your data</li>
    <li>it's easier to debug, as you know what is coming from where</li>
    <li>it's more efficient, as the library already knows what the boundaries are of each part of the system</li>
  </ul>
  <p>A state is always owned by one Component. Any data that's affected by this state can only affect Components below it:
    its children. Changing state on a Component will never affect its parent, or its siblings, or any other Component in
    the application: just its children. This is the reason that the state is often moved up in the Component tree, so that
    it can be shared between components that need to access it.</p>

  <p>Best Practices:-</p>
  <ul>
    <li>Always start component names with a capital letter. <br />
      React treats components starting with lowercase letters as DOM tags. For example, <em>&#x3C;div /&#x3E;</em>
      represents an HTML div tag, but <em>&#x3C;Welcome /&#x3E;</em> represents a component and requires Welcome to be in
      scope.</li>
  </ul>

  <h1>React</h1>
  <p>React is a JavaScript library for building user interfaces across a variety of platforms(VR, Mobile). React gives
    you a powerful mental model to work with and helps you build user interfaces in a declarative and component
    driven
    way. </p>
  <ul>
    <li><strong>Components</strong> - Encapsulated units of functionality that are the primary unit in React. They
      utilize data (properties and state) to render your UI as output; Certain types of React components also provide
      a
      set of
      lifecycle methods that you can hook into. The rendering process (outputting and updating a UI based on your
      data) is predictable in React, and your components can hook into it using React’s APIs. Components in React are
      meant
      to work together. This means you can compose together components to form new composite components. Component
      composition is one of the most powerful aspects of React.
      <figure><img src="img/img-8.gif" alt="" /></figure>
    </li>
    <li><strong>React libraries </strong>— React uses a set of core libraries. The core React library works with the
      react dom and react native libraries and is focused on component specification and definition.
      <ol>
        <li><strong>React DOM</strong> is a renderer for React that was split off from the main React library to
          better
          separate concerns; it handles rendering components to the DOM or to a string for serverside rendering.</li>
        <li> <strong>The proptypes library</strong> is a
          development library that will help you do some type checking on data passed to your components.</li>
        <li><strong>The React Native libraries</strong> focus
          on native platforms and let you create React applications for iOS, Android, and other platforms.</li>
      </ol>
    </li>
    <li><strong>Third party libraries</strong> — React doesn’t come with tools for data modeling, HTTPcalls, styling
      libraries, or other common aspects of a frontend application. This leaves you free to use additional code,
      modules, or other tools you prefer in yourapplication. And even though these common technologies don’t come
      bundled withReact, the
      broader ecosystem around React is full of incredibly useful libraries.</li>
    <li><strong>Virtual DOM</strong> - A virtual DOM is a data structure or collection of data structures that mimics
      or
      mirrors the Document Object Model that exists in browsers. React’s virtual DOM handles change detection in data
      as
      well as translating browser events into events that React components can understand and react to. React’s
      virtual DOM also aims to optimize changes made to the DOM for the sake of performance.</li>
    <figure><img src="img/img-9.gif" alt="" /></figure>
    <p><strong>The DOM, or Document Object Model</strong>, is a programming interface that allows your JavaScript
      programs to interact with different types of documents(HTML, XML, and SVG). There are standards driven
      specifications for it, which means that a public working group has created a standard set of features it
      should
      have and ways it should behave. Although other implementations exist, the DOM is mostly synonymous with web
      browsers like Chrome, Firefox, and Edge.</p>
    <p>The DOM provides a structured way of accessing, storing, and manipulating different parts of a document. At a
      high level, the DOM is a tree structure that reflects the hierarchy of an XML document. This tree structure is
      comprised of subtrees that are in turn made of nodes. You’ll probably know these as the divs and other
      elements
      that make up your web pages and applications.</p>
    <p>Whenever you use a method in JavaScript that accesses, modifies, or storesinformation related to something
      in
      an HTML document, you’re almost certainly using the DOM or its related APIs (see
      https://developer.mozilla.org/enUS/docs/Web/API formore on web APIs). This means that not all the methods
      you’ve used in JavaScript are necessarily part of the JavaScript language itself
      (document.findElemenyById,querySelectorAll, alert, and so on). They’re part of the bigger collection of
      web APIs—the DOM and other APIs that go into a browser—that allow you to interact with documents.</p>
    <p>The web APIs in browsers let us interact with web documents with JavaScript via the DOM. Thereare, however,
      certain pain points of working directly with the DOM in larger web applications. Generally, these pain points
      arise in the area of change detection. Part of the reason for that problem is the way browsers handle
      interactions with the DOM. When a DOM element is accessed, modified, or created, the browser is
      often performing
      a query across a structured tree to find a given element. That’s just to access an element, which is usually
      only the first part of an update. More often than not, it may have to reperform layout, sizing, and other
      actions as part of a mutation—all of which can tend to be computationally expensive. A virtual DOM won’t get
      you
      around this, but it can help updates to the DOM be optimized to account for these constraints.</p>
    <p><strong>React’s diffing and update procedure</strong> - When a change happens, React determines differences
      between the actual and in-memory DOMs. Then it performs an efficient update to the browser’s DOM. This process
      is often referred to as a diff (“what changed?") and patch (“update only what changed") process.
      <figure><img src="img/img-10.gif" alt="" /></figure>
    </p>
    <p>Performance is a key feature of React, but it’s secondary to simplicity. The virtual DOM is part of what
      enables you to defer thinking about complicated state logic and focus on other, more important parts of your
      application. Together, speed and simplicity mean happier users and happierdevelopers—a winwin!</p>
    </li>
  </ul>
  <figure><img src="img/react-map.svg" alt="" /></figure>

  <!--<p><strong>What is an API?</strong> An API, or, application programming interface, is a set ofroutines and protocols for building
      software. That might sound vague, and it is a prettygeneral definition. API is a broad term, applying to everything
      from company platformsto open source libraries.In web development and engineering, API has become almost synonymous
      with aremote, webbased public API. This means that an API is usually a way of exposingdefined ways to interact
      with a program or platform, usually over the internet, and forpeople to use and consume.</p-->

  



	<h2 id="reactElement">Create React elements/components</h2>
  
	<p>A <strong>React element</strong> is a light, stateless, immutable primitive in React. There are two types:
    <strong>React
      DOM Element</strong> and <strong>React Component Element</strong>.</p>
  <p>React.createElement takes a string or component (either a class extending React.Component or a function), a props
    object, and children and returns a Reactelement.</p>
  <p>React DOM Elements are virtual representations of DOM elements. React Component Elements reference either a
    function or a class corresponding to a React component.</p>

  <pre><code class="language-jsx">
    // ES6 and latest way to create react component
    import React, { Component } from 'react';  // importing member and default export together in next-gen JavaScript by Babel compiler

    class App extends Component {
      render() {
        return (
          &lt;h1&gt;Heading&lt;/h1&gt;
        );
      }
    }
    
    export default App;  
  </code></pre>

  <pre><code class="language-jsx">
    // previos and ES6 way to create react component when full React import in 'react' identifier. 
    import React from 'react';

    class App extends React.Component {
      render() {
        return (
          &lt;h1&gt;Heading&lt;/h1&gt;
        );
      }
    }
    
    export default App;  
  </code></pre>

  <pre><code class="language-jsx">
    // previos and ES6 way to create react component when full React import in 'react' identifier. 
    import React from 'react';

    // create react element without JSX
    // React.createElement(component, props, ...childrenComponent)
    class Hello extends React.Component {
      render() {
        return React.createElement('div', null, `Hello ${this.props.toWhat}`);
      }
    }
    
    ReactDOM.render(
      React.createElement(Hello, {toWhat: 'World'}, null),
      document.getElementById('root')
    );
  </code></pre>

  <pre><code class="language-jsx">
    // If you don&#x2019;t use ES6 yet, you may use the create-react-class module instead to define a React component
    var createReactClass = require(&#x27;create-react-class&#x27;);
    var Greeting = createReactClass({
      render: function() {
        return &#x3C;h1&#x3E;Hello, {this.props.name}&#x3C;/h1&#x3E;;
      }
    });
  </code></pre>

  <pre><code class="language-jsx">
    // create &#x201C;function components&#x22; with plain Javascript without Class
    // it accepts a single &#x201C;props&#x22; (which stands for properties) object argument with data and returns a React element.
    function Welcome(props) {
      return &#x3C;h1&#x3E;Hello, {props.name}&#x3C;/h1&#x3E;;
    }
  </code></pre>

  <h3>Render React elements in React DOM(Virtual DOM)</h3>
  <p>Use <code class="language-jsx">ReactDOM.render()</code> method manage components or react elements.</p>
  <p>React DOM needs an element of type <strong>React Element</strong> and a <strong>DOM element</strong> to run render
    action..</p>

  <pre><code class="language-jsx">
    // ReactDOM.render(ReactElement, DOMcontainer[, callback])
    const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
    ReactDOM.render(element, document.getElementById('root'));
  </code></pre>

  <p>React elements are immutable. Once you create an element, you can’t change its children or attributes. An element
    is like a single frame in a movie: it represents the UI at a certain point in time.</p>
  <p>Only way to update the UI is to create a new element, and pass it to <code class="language-jsx">ReactDOM.render()</code>.</p>
  <pre><code class="language-jsx">
    function tick() {
      const element = (
        &lt;div&gt;
          &lt;h1&gt;Hello, world!&lt;/h1&gt;
          &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
        &lt;/div&gt;
      );
      ReactDOM.render(element, document.getElementById('root'));
    }
    
    setInterval(tick, 1000);
  </code></pre>

  <pre><code class="language-jsx"></code>
    class App extends Component {
      render() {
        return (
          <div className="App">
            <header className="App-header">
              <h1></h1>
            </header>
          </div>
        );
      }
    }
  </code></pre>

  <pre class="language-js"><code class="language-jsx">
    import React, { Component } from 'react';
    import { render } 'reactdom';

    const node = document.getElementById('root');
    const root = React.createElement('div', {}, 
      React.createElement('h1', {}, "Hello, world!", 
        React.createElement('a', {href: 'mailto:mark@ifelse.io'},
          React.createElement('h1', {}, "React In Action"),
            React.createElement('em', {}, "...and now it really is!")
        )
      )
      );
    render(root, node); //
  </code></pre>


  <h2 id="reactInstallation">React Installation</h2>
  <p><strong>"create-react-app"</strong>, a command-line interface (CLI) tool that allows us to set up a
    React-based application without need to configure any of the aforementioned tools.</p>

  <pre><code class="language-jsx">
    // Install "Create react app" globally
    npm uninstall -g create-react-app
    npm install -g create-react-app
    create-react-app --version
  </code></pre>

  <pre><code class="language-jsx">
    // Start to create "my-react-app" project in your local directory. 
    npx create-react-app my-react-app
  </code></pre>

  <h3>React Basic folder structure</h3>
  <figure><img src="img/img-1.png" alt="" /></figure>
  <ol>
    <li> <strong>manifest.json</strong>: This is a configuration file containing metadata according to the
      Progressive Web Apps (PWA) criteria. This manifest contains metadata for configuring our app as a PWA.
      <strong>Progressive web apps(PWA)</strong> are web applications that work for every browser and every platform,
      even offline.
      Their basic tenet is responsiveness and progressive enhancement. manifest.json provides metadata used when your
      web app is added to the homescreen on Android. <img src="img/img-2.png" alt="" /> </li>

    <li><strong>registerServiceWorker.js: </strong> Contains the code to register the service worker in order to
      allow offline behavior, as per the PWA requirements, while the import of index.css makes the CSS styling
      available to the application.</li>
    <li> We notice one thing in index.html file is the %PUBLIC_URL% placeholder in both link references. This
      placeholder will be replaced with the actual URL of the public folder during the build process.
      <figure><img src="img/img-3.png" alt="" /></figure>
      </p>
    </li>
  </ol>

  <h3>How React initialize</h3>
  <p>You need to add a new DOM element with an ID of <code class="language-jsx">root</code> as well as some basic code that uses
    <strong>React
      DOM</strong>.</p>
  <p>Define <code class="language-jsx">root id</code> to render &lt;App /&gt; component inside.</p>
  
  <pre class="language-html"><code class="language-jsx">
    // index.html inside public folder
    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
      &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot;&gt;
        &lt;link rel=&quot;shortcut icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot;&gt;

        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&gt;
        &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot;&gt;
        &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot;&gt;
        
        &lt;title&gt;React App&lt;/title&gt;
      &lt;/head&gt;
      &lt;body&gt;      
        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;     
  </code></pre>

  <p>Call <strong>app.js</strong> component's module to render in <code class="language-jsx">root id</code> tag</p>

  <pre><code class="language-jsx">
    // index.js file inside src folder
    import React from 'react';
    import ReactDOM from 'react-dom';
    import './index.css';
    import App from './App';
    import * as serviceWorker from './serviceWorker';
    
    ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));
    
    // If you want your app to work offline and load faster, you can change
    // unregister() to register() below. Note this comes with some pitfalls.
    // Learn more about service workers: http://bit.ly/CRA-PWA
    serviceWorker.unregister();
  </code></pre>

  <figure><img src="img/img-4.png" alt="" /></figure>
  <p>The <strong>react module</strong> provides functionality for component creation and state management. The
    <strong>react-dom
      module</strong> is
    the
    glue between React components and the HTML DOM.</p>
  <pre><code class="language-jsx">
    npm run build
  </code></pre>
  <p>The result of running this command is a new BUILD folder where we will find all of the files that we need to
    move
    into a production environment. The command carries out some processing on the files of our development
    environment.
    Put simply, it translates all of the ES2015 code we wrote into ES5 compatible code, so that it is also
    available
    for older browsers. This process is called transpilation. In addition, it reduces the size of the code
    itself,
    allowing for faster downloading over the network. This process is called minification. Finally, it takes the
    files
    in our
    development environment and combines them into a few files, called bundles, in order to decrease network
    requests.</p>

  <h4>Building for Relative Paths</h4>
  <p>By default, Create React App produces a build assuming your app is hosted at the server root.<br />
    To override this, specify the homepage in your package.json, for example:</p>
  <pre><code class="language-jsx">
    "homepage": "http://mywebsite.com/relativepath",
  </code></pre>
  
  
  
  
  <h2 id="jsxIntro">Getting started with JSX</h2>
  
  <p>JSX is a technology that was introduced by React.</p>
  
  <p>Although React can work completely fine without using JSX, it’s an ideal technology to work with components,
    so
    React benefits a lot from JSX.</p>
  
  <h3>Introduction to JSX</h3>
  
  <p>You might think that using JSX is like mixing HTML and JavaScript. But this is not true, because what you
    are really doing when using JSX syntax is writing a declarative syntax of what a component UI should be.</p>
  
  <p>And you’re describing that UI not using strings, but instead using JavaScript. </p>
  <br />
  <pre><code class="language-jsx">
    const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;
  </code></pre>

  <p>It looks like a strange mix of JavaScript and HTML, but in reality it’s all JavaScript.</p>
  <br />
  <p>Inside a JSX expression, attributes can be inserted very easily:</p>
  <pre><code class="language-jsx">
    const myId = 'test'
    const element = &lt;h1 id={myId}&gt;Hello, world!&lt;/h1&gt;
  </code></pre>
  <br />
  <p>You just need to pay attention when an attribute has a dash (-) which is converted to camelCase syntax
    instead, and these 2 special cases:</p>
  <ul>
    <li><code class="language-jsx">class</code> becomes <code class="language-jsx">className</code></li>
    <li><code class="language-jsx">for</code> becomes <code class="language-jsx">htmlFor</code></li>
  </ul>
  <p>because they are reserved words in JavaScript.</p>
  <br />
  <p>In Below code, wrapped the 2 components into a div. Why? Because the <code class="language-js">render()</code> function can only
      return a
      single node.</p>
  
  <pre><code class="language-jsx">
    &lt;div&gt;
      &lt;BlogPostsList /&gt;
      &lt;Sidebar /&gt;
    &lt;/div&gt;
  </code></pre>

  <h3>TRANSPILING JSX</h3>
  <p>JSX code must be first transformed into regular JS to excute on browser.</p>
  <p>In the below code, JSX is transpiled into plain JS by transpiler.</p>
  
  <pre><code class="language-jsx">
    ReactDOM.render(
      &lt;div id=&quot;test&quot;&gt;
        &lt;h1&gt;A title&lt;/h1&gt;
        &lt;p&gt;A paragraph&lt;/p&gt;
      &lt;/div&gt;,
      document.getElementById('myapp')
    )
  </code></pre>

  <p>Into Plain JS</p>

  <pre class="language-js"><code class="language-jsx">
    ReactDOM.render(
      React.DOM.div(
        { id: 'test' },
        React.DOM.h1(null, 'A title'),
        React.DOM.p(null, 'A paragraph')
      ),
      document.getElementById('myapp')
    )
  </code></pre>

  <p>At the time of writing the most popular way to perform the transpilation is to use Babel.</p>

  <h3>JS IN JSX</h3>
  <p>JSX accepts any kind of JavaScript mixed into it.</p>
  <p>Whenever you need to add some JS, just put it inside curly braces {}. For example here’s how to use a constant value
    defined elsewhere:</p>

  <pre><code class="language-jsx">
    const paragraph = 'A paragraph'
    ReactDOM.render(
      &lt;div id=&quot;test&quot;&gt;
        &lt;h1&gt;A title&lt;/h1&gt;
        &lt;p&gt;{paragraph}&lt;/p&gt;
      &lt;/div&gt;,
      document.getElementById('myapp')
    )
  </code></pre>
  
  <p>Curly braces accept any JS code:</p>
  
  <pre><code class="language-jsx">
    ReactDOM.render(
      &lt;table&gt;
        {rows.map((row, i) =&gt; {
          return &lt;tr&gt;{row.text}&lt;/tr&gt;
        })}
      &lt;/div&gt;,
      document.getElementById('myapp')
    )
  </code></pre>

  <p>As you can see we nested JavaScript inside a JSX that defined inside a JavaScript which nested in a JSX. You can go
    as deep as you need.</p>
  
  <h3>HTML IN JSX</h3>

  <p>JSX resembles a lot HTML, but it’s actually a XML syntax.</p>
  <h4>YOU NEED TO CLOSE ALL TAGS</h4>
  <p>Just like in XHTML, if you have ever used it, you need to close all tags: no more <code class="language-jsx">&lt;br&gt;</code> but
    instead use the self-closing tag: <code class="language-jsx">&lt;br /&gt;</code> (the same goes for other tags)</p>
  <h4>CAMELCASE IS THE NEW STANDARD</h4>
  <p>In HTML you’ll find attributes without any case (e.g. <code class="language-jsx">onchange</code>). In JSX, they are renamed to
    their camelCase equivalent: </p>
  <ul>
    <li><code class="language-jsx">onchange</code> =&gt; <code class="language-jsx">onChange</code></li>
    <li><code class="language-jsx">onclick</code> =&gt; <code class="language-jsx">onClick</code></li>
    <li><code class="language-jsx">onsubmit</code> =&gt; <code class="language-jsx">onSubmit</code></li>
  </ul>

  <h3>CLASS BECOMES <strong>CLASSNAME</strong></h3>

  <p>Due to the fact that JSX is JavaScript, and class is a reserved word, you can’t write</p>
  
  <pre><code class="language-jsx">
    &lt;p class=&quot;description&quot;&gt;
  </code></pre>
  
  <p>you need to use</p>
  
  <pre><code class="language-jsx">
    &lt;p className=&quot;description&quot;&gt;
  </code></pre>
  
  <p>The same applies to <strong>for</strong> which is translated to <strong>htmlFor</strong>.</p>

  <h3>CSS IN REACT</h3>
  <p>You can't write inline style tag in JSX. The JSX style attribute only accepts an object. This means you
    define
    properties in an object:</p>
  
  <pre><code class="language-jsx">
    var divStyle = {
      color: 'white'
    }
    
    ReactDOM.render(&lt;div style={divStyle}&gt;Hello World!&lt;/div&gt;, mountNode)
  </code></pre>
  
  <p>or</p>
  
  <pre><code class="language-jsx">
    ReactDOM.render(&lt;div style={{ color: 'white' }}&gt;Hello World!&lt;/div&gt;, mountNode)
  </code></pre>
  
  <br />
  <p>Inline styles in JSX are good until you need to</p>
  <ol>
    <li>write media queries</li>
    <li>style animations</li>
    <li>reference pseudo classes (e.g. <code class="language-jsx">:hover</code>)</li>
    <li>reference pseudo elements (e.g. <code class="language-jsx">::first-letter</code>)</li>
  </ol>
  <h3>FORMS IN JSX</h3>
  <h4 id="value-and-defaultvalue"><code class="language-jsx">value</code> and <code class="language-jsx">defaultValue</code></h4>
  <p>The <code class="language-jsx">value</code> attribute always holds the current value of the field.</p>
  <p>The <code class="language-jsx">defaultValue</code> attribute holds the default value that was set when the field was created.</p>
  <p><em>This helps solve some weird behavior of regular DOM interaction when inspecting <code class="language-jsx">input.value</code> and
      <code class="language-js">input.getAttribute('value')</code> returning one the current value and one the original
      default value.</em></p>
  <p>This also applies to the <code class="language-jsx">textarea</code> field, e.g.</p>

  <pre><code class="language-html">
    &lt;textarea&gt;Some text&lt;/textarea&gt;
  </code></pre>

  <p>but instead</p>
  <pre><code class="language-jsx">
    &lt;textarea defaultValue={'Some text'} /&gt;
  </code></pre>

  <p>For <code class="language-jsx">select</code> fields, instead of using</p>

  <pre><code class="language-jsx">
    &lt;select&gt;
      &lt;option value=&quot;x&quot; selected&gt;
        ...
      &lt;/option&gt;
    &lt;/select&gt;
  </code></pre>

  <p>use</p>

  <pre><code class="language-jsx">
    &lt;select defaultValue=&quot;x&quot;&gt;
      &lt;option value=&quot;x&quot;&gt;...&lt;/option&gt;
    &lt;/select&gt;
  </code></pre>

  <h2 id="jsx-auto-escapes">JSX auto escapes</h2>
  <p>To mitigate the ever present risk of XSS exploits, JSX forces automatic escaping in expressions.</p>
  <p>This means that you might run into issues when using an HTML entity in a string expression.</p>
  <p>You expect the following to print <code class="language-jsx">© 2017</code>:</p>
  
  <pre><code class="language-jsx">
    &lt;p&gt;{'&amp;copy; 2017'}&lt;/p&gt;
  </code></pre>

  <p>But it&rsquo;s not, it&rsquo;s printing <code class="language-jsx">&amp;copy; 2017</code> because the string is escaped.</p>
  <p>To fix this you can either move the entities outside the expression:</p>
  
  <pre><code class="language-html">
    &lt;p&gt;&amp;copy; 2017&lt;/p&gt;
  </code></pre>
  
  <p>or by using a constant that prints the Unicode representation corresponding to the HTML entity you need to
    print:</p>
  
  <pre><code class="language-jsx">
    &lt;p&gt;{'\u00A9 2017'}&lt;/p&gt;
  </code></pre>

  <h3 id="white-space-in-jsx">White space in JSX</h3>
  <p>To add white space horizontal/vertical in JSX there are 2 rules:</p>
  
  <pre><code class="language-html">
    &lt;p&gt;
    Something
    {' '}becomes
    {' '}this
    &lt;/p&gt;
  </code></pre>

  <p>or by embedding the string in a space expression:</p>
  
  <pre><code class="language-html">
    &lt;p&gt;
    Something
    {' becomes '}
    this
    &lt;/p&gt;
  </code></pre>

  <h3>Spread attributes</h3>
  <p>In JSX a common operation is assigning values to attributes.</p>
  <p>Instead of doing it manually, e.g.</p>
  
  <pre><code class="language-jsx">
    &lt;div&gt;
      &lt;BlogPost title={data.title} date={data.date} /&gt;
    &lt;/div&gt;
  </code></pre>
  
  <p>you can pass</p>
  
  <pre><code class="language-jsx">
    &lt;div&gt;
      &lt;BlogPost {...data} /&gt;
    &lt;/div&gt;
  </code></pre>

  <p>and the properties of the <code class="language-jsx">data</code> object will be used as attributes automatically, thanks to the <em>ES6
      spread operator</em></p>
  
  <h3>How to loop in JSX</h3>
  <p>If you have a set of elements you need to loop upon to generate a JSX partial, you can create a loop, and then add JSX to an array:</p>
  <pre><code class="language-jsx">
    const elements = [] //..some array

    const items = []
    
    for (const [index, value] of elements.entries() {
      items.push(&#x3C;Element key={index} /&#x3E;)
    }
  </code></pre>

  <p>Now when rendering the JSX you can embed the items array simply by wrapping it in curly braces:</p>

  <pre><code class="language-jsx">
    const elements = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;];

    const items = []
    
    for (const [index, value] of elements.entries() {
      items.push(&#x3C;li key={index}&#x3E;{value}&#x3C;/li&#x3E;)
    }
    
    return (
      &#x3C;div&#x3E;
        {items}
      &#x3C;/div&#x3E;
    )
  </code></pre>
  
  <p>You can do the same directly in the JSX, using map instead of a for-of loop:</p>

  <pre><code class="language-jsx">
    const elements = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;];
    return (
      &#x3C;ul&#x3E;
        {elements.map((value, index) =&#x3E; {
          return &#x3C;li key={index}&#x3E;{value}&#x3C;/li&#x3E;
        })}
      &#x3C;/ul&#x3E;
    )
  </code></pre>

  
  
  
  <h2 id="componentInDetails">Everything Is a Component</h2>

  <p>React makes it very simple: everything is a component. A component is one isolated piece of interface.</p>
  <p>A user interface is an aggregate of components, and the whole React application is an aggregate of
    components. </p>
  <p>The container components are components that do not have a relevant visual effect. Their main role is to
    group other components, that is, contain other components. </p>
  <p> The presentational components are components that display data in some graphical form.</p>
  <p><img src="img/img-7.png" alt="Browser console inspecting React.DOM" /></p>
  <p>The next 2 lines are equivalent, they do the same thing. One with <strong>JSX</strong>, one without, by
    injecting <code class="language-jsx">&lt;h1&gt;Hello World!&lt;/h1&gt;</code> into an element with id <code class="language-jsx">app</code>.</p>
  <pre><code class="language-jsx">
    import React from 'react'
    import ReactDOM from 'react-dom'
    
    ReactDOM.render(
      &lt;h1&gt;Hello World!&lt;/h1&gt;,
      document.getElementById('app')
    )
    
    ReactDOM.render(
      React.DOM.h1(null, &quot;Hello World!&quot;),
      document.getElementById('app')
    )
  </code></pre>
  
  <p>See, <code class="language-jsx">React.DOM</code> exposed us an <code class="language-jsx">h1</code> component. Which other HTML tags are available?
    All of them! You can inspect what <code class="language-jsx">React.DOM</code> offers by typing it in the Browser Console:</p>
  <p><img src="img/img-6.png" alt="Browser console inspecting React.DOM" /></p>
  
  <p>There are 2 ways to define a component in React.</p>
  <p>A function component:</p>
  <pre><code class="language-jsx">
    const BlogPostExcerpt = () =&#x3E; {
      return (
        &#x3C;div&#x3E;
          &#x3C;h1&#x3E;Title&#x3C;/h1&#x3E;
          &#x3C;p&#x3E;Description&#x3C;/p&#x3E;
        &#x3C;/div&#x3E;
      )
    }
  </code></pre>
  <p>A class component:</p>
  <pre><code class="language-jsx">
    import React, { Component } from &#x27;react&#x27;

    class BlogPostExcerpt extends Component {
      render() {
        return (
          &#x3C;div&#x3E;
            &#x3C;h1&#x3E;Title&#x3C;/h1&#x3E;
            &#x3C;p&#x3E;Description&#x3C;/p&#x3E;
          &#x3C;/div&#x3E;
        )
      }
    }
  </code></pre>
  <p>Up until recently, class components were the only way to define a component that had its own state, and could access the lifecycle methods so you could do things when the component was first rendered, updated or removed.</p>
  <p>React Hooks changed this, so our function components are now much more powerful than ever and I believe we'll see fewer and fewer class components in the future, although it will still be perfectly valid way to create components.</p>
  <p>There is also a third syntax which uses the ES5 syntax, without the classes:</p>
  <pre><code class="language-jsx">
    import React from &#x27;react&#x27;

    React.createClass({
      render() {
        return (
          &#x3C;div&#x3E;
            &#x3C;h1&#x3E;Title&#x3C;/h1&#x3E;
            &#x3C;p&#x3E;Description&#x3C;/p&#x3E;
          &#x3C;/div&#x3E;
        )
      }
    })
  </code></pre>
  <h3>CUSTOM COMPONENTS</h3>
  <p>A stateless component does not manage internal state, and is just a function:</p>
  
  <pre><code class="language-jsx">
    const BlogPostExcerpt = () =&gt; {
        return (
          &lt;div&gt;
            &lt;h1&gt;Title&lt;/h1&gt;
            &lt;p&gt;Description&lt;/p&gt;
          &lt;/div&gt;
        )
      }
  </code></pre>

  <p>A stateful component is a class, which manages state in its own properties:</p>
  
  <pre><code class="language-jsx">
    import React, { Component } from 'react'

      class BlogPostExcerpt extends Component {
        render() {
          return (
            &lt;div&gt;
              &lt;h1&gt;Title&lt;/h1&gt;
              &lt;p&gt;Description&lt;/p&gt;
            &lt;/div&gt;
          )
        }
      }
  </code></pre>

  <p>There is a third syntax which uses the <code class="language-jsx">ES5</code> syntax, without the classes:</p>
  
  <pre><code class="language-jsx">
    import React from 'react'

      React.createClass({
        render() {
          return (
            &lt;div&gt;
              &lt;h1&gt;Title&lt;/h1&gt;
              &lt;p&gt;Description&lt;/p&gt;
            &lt;/div&gt;
          )
        }
      })
  </code></pre>

  <p>React classes also gives you state(data) that can persist with the component. What’s state? Another way to think
    about it is as information about something at agiven time. You could, for example, get the “state" of your friend
    by asking “How are you today?"</p>
  <p>There are two general types of state: mutable and immutable. A simple way to thinkabout the difference between
    them is to think in terms of time. Can something change after being created? If so, it can be called mutable. If
    not, it can be called immutable.</p>
  <p>In React, components created as JavaScript classes that extend React.Component may have both mutable and
    immutable state, whereas components created from functions(stateless functional components) only have access to
    immutable state (props).</p>
  
  <h4>Presentational vs container components</h4>
  <p>In React components are often divided into 2 big buckets: presentational components and container components. Each of
    those have their unique characteristics. Presentational components are mostly concerned with generating some markup to
    be outputted. They don't manage any kind of state, except for state related the the presentation. Container components
    are mostly concerned with the "backend" operations.
  </p>
  <p>They might handle the state of various sub-components. They might wrap several presentational components. They might
    interface with Redux. As a way to simplify the distinction, we can say presentational components are concerned with
    the look, container components are concerned with making things work.</p>
  <p>For example, this is a presentational component. It gets data from its props, and just focuses on showing an element:</p>
  
  <pre><code class="language-jsx">
    const Users = props =&#x3E; (
      &#x3C;ul&#x3E;
        {props.users.map(user =&#x3E; (
          &#x3C;li&#x3E;{user}&#x3C;/li&#x3E;
        ))}
      &#x3C;/ul&#x3E;
    )
  </code></pre>

  <p>On the other hand this is a container component. It manages and stores its own data, and uses the presentational component to display it.</p>
  <pre><code class="language-jsx">
    class UsersContainer extends React.Component {
      constructor() {
        this.state = {
          users: []
        }
      }
    
      componentDidMount() {
        axios.get(&#x27;/users&#x27;).then(users =&#x3E;
          this.setState({ users: users }))
        )
      }
    
      render() {
        return &#x3C;Users users={this.state.users} /&#x3E;
      }
    }
  </code></pre>


  
  
  
  <h2 id="reactProps">Props</h2>
  <p> Props is how Components get their properties. Starting from the top component, every child component gets its props
    from the parent. In a function component, props is all it gets passed, and they are available by adding props as the
    function argument:</p>
  <pre><code class="language-jsx">
      const BlogPostExcerpt = props =&#x3E; {
        return (
          &#x3C;div&#x3E;
            &#x3C;h1&#x3E;{props.title}&#x3C;/h1&#x3E;
            &#x3C;p&#x3E;{props.description}&#x3C;/p&#x3E;
          &#x3C;/div&#x3E;
        )
      }
    </code></pre>
  <p>In a class component, props are passed by default. There is no need to add anything special, and they are accessible
    as <code class="language-jsx">this.props</code> in a Component instance.</p>
  
  <pre><code class="language-jsx">
      import React, { Component } from &#x27;react&#x27;
  
      class BlogPostExcerpt extends Component {
        render() {
          return (
            &#x3C;div&#x3E;
              &#x3C;h1&#x3E;{this.props.title}&#x3C;/h1&#x3E;
              &#x3C;p&#x3E;{this.props.description}&#x3C;/p&#x3E;
            &#x3C;/div&#x3E;
          )
        }
      }
    </code></pre>
  
  <p>Passing props down to child components is a great way to pass values around in your application. A component either
    holds data (has state) or receives data through its props.</p>
  <p class="list-heading"><strong>It gets complicated when:</strong></p>
  <uL>
    <li>you need to access the state of a component from a child that's several levels down (all the previous children
      need to act as a pass-through, even if they do not need to know the state, complicating things)
    </li>
    <li>you need to access the state of a component from a completely unrelated component.</li>
  </uL>
  <!--p>System for passing data from a parent component to a child component to customize or configure a child component.</p-->

  <p>Props are immutable (not modifiable), so if you need to change data, you need mutable state. </p>
  
  <!--p>Whether you declare a component as a function or a class, it must never modify its own props. </p>

  <p>In the components created by <code class="language-jsx">React.Component</code>, state is accessible from the <code class="language-jsx">this.state</code>
  property of the instance of the class. The immutable state made available to you is accessed with this.props, which you’ve been using already
  to create static components.</p-->

  <!--p>You may be wondering how you might use state and props in React. The answer is pretty much how you would use data
  passed to or used in a function. That includes calculations, display, parsing, business logic, and any other
  data related tasks. In fact, props and state are the primary ways that you can utilize dynamic or static data in
  your UI (showing user information, passing data to event handlers, and so forth).</p-->

  <!--p>You can use the constructor of the component to set the initial state for your component</p-->

  <!--p><strong>Props</strong> is how Components get their properties. Starting from the top component, every child
  component gets its props from the parent.</p-->

  <h4>How props are passed</h4>
  <p>When initializing a component, pass the props in a way similar to HTML attributes:</p>
  <pre><code class="language-jsx">
    const desc = 'A description'
    //...
    &lt;BlogPostExcerpt title=&quot;A blog post&quot; description={desc} /&gt;
  </code></pre>

  <pre><code class="language-jsx">
    import React, { Component } from 'react'

    class BlogPostExcerpt extends Component {
      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;{this.props.title}&lt;/h1&gt;
            &lt;p&gt;{this.props.description}&lt;/p&gt;
          &lt;/div&gt;
        )
      }
    }
  </code></pre>

  <p>In a stateful component(class based), props are passed by default. There is no need to add anything special, and they are
    accessible as <code class="language-jsx">this.props</code> in a Component instance.</p>

  <p>In a stateless component(function based), props is all it gets passed, and they are available by adding <code class="language-jsx">props</code> as the
    function argument:</p>

  <pre><code class="language-jsx">
    const BlogPostExcerpt = props =&gt; {
      return (
        &lt;div&gt;
          &lt;h1&gt;{props.title}&lt;/h1&gt;
          &lt;p&gt;{props.description}&lt;/p&gt;
        &lt;/div&gt;
      )
    }
  </code></pre>

  <p><strong>Redux</strong> was traditionally very popular for this, and this is the reason it&rsquo;s included in
    many tutorials.</p>

  <p>Recently React (in version 16.3.0) introduced the <strong>Context API</strong>, which makes Redux redundant for
    this simple use case.</p>

  <p>Redux is still useful if you:</p>
  <ul>
    <li>need to move your data outside of the app altogether for some reason</li>
    <li>create complex reducers and actions to manipulate the data in any way you want</li>
  </ul>

  <p>but it&rsquo;s no more &ldquo;required&rdquo; for any React application.</p>


  <h4>DEFAULT VALUES FOR PROPS</h4>
  <p>If any value is not required we need to specify a default value for it if it&rsquo;s missing when the Component
    is initialized.</p>

  <pre><code class="language-jsx">
    BlogPostExcerpt.propTypes = {
      title: PropTypes.string,
      description: PropTypes.string
    }

    BlogPostExcerpt.defaultProps = {
      title: &#x27;&#x27;,
      description: &#x27;&#x27;
    }
  </code></pre>

  <p>Some tooling like <strong>ESLint</strong> have the ability to enforce defining the defaultProps for a Component
    with
    some propTypes not explicitly required.</p>

  <h4 id="children">Children</h4>
  <p>A special prop is <code class="language-jsx">children</code>. That contains the value of anything that is passed in the
    <code class="language-jsx">body</code>
    of the component, for example:</p>

  <pre><code class="language-html">
    &lt;BlogPostExcerpt title=&quot;A blog post&quot; description={desc}&gt;
    Something
    &lt;/BlogPostExcerpt&gt;
  </code></pre>

  <p>In this case, inside <code class="language-jsx">BlogPostExcerpt</code> we could access &ldquo;Something&rdquo; by looking up
    <code class="language-jsx">this.props.children</code>.</p>

  <p>While Props allow a Component to receive properties from its parent, be &ldquo;instructed&rdquo; to print some
    data
    for example, state allows a component to take life on itself, and be independent of the surrounding
    environment.</p>

  <p><strong>Remember</strong>: only class-based Components can have a state, so if you need to manage state in a
    stateless(function-based) Component, you first need to &ldquo;upgrade&rdquo; it to a Class component:</p>

  <pre><code class="language-js">
  const BlogPostExcerpt = () =&gt; {
    return (
      &lt;div&gt;
        &lt;h1&gt;Title&lt;/h1&gt;
        &lt;p&gt;Description&lt;/p&gt;
      &lt;/div&gt;
    )
  }
  </code></pre>

  <p>becomes:</p>
  <pre><code class="language-js">
    import React, { Component } from 'react'

    class BlogPostExcerpt extends Component {
      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Title&lt;/h1&gt;
            &lt;p&gt;Description&lt;/p&gt;
          &lt;/div&gt;
        )
      }
    }
  </code></pre>



  <h2 id="reactProptypes">Proptypes</h2>
  <p>Since JavaScript is a dynamically typed language, we don&rsquo;t really have a way to enforce the type of a
    variable at compile time, and if we pass invalid types, they will fail at runtime or give weird results if the
    types
    are compatible but not what we expect.</p>

  <p>Flow and TypeScript help a lot, but React has a way to directly help with props types, and even before
    running the code, our tools (editors, linters) can detect when we are passing the wrong values:</p>

  <pre><code class="language-jsx">
    import PropTypes from 'prop-types'
    import React from 'react'

    class BlogPostExcerpt extends Component {
      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;{this.props.title}&lt;/h1&gt;
            &lt;p&gt;{this.props.description}&lt;/p&gt;
          &lt;/div&gt;
        )
      }
    }

    BlogPostExcerpt.propTypes = {
      title: PropTypes.string,
      description: PropTypes.string
    }

    export default BlogPostExcerpt
  </code></pre>

  <h3 id="which-types-can-we-use">Which types can we use</h3>
  <p>These are the fundamental types we can accept:</p>
  <ul>
    <li>PropTypes.array</li>
    <li>PropTypes.bool</li>
    <li>PropTypes.func</li>
    <li>PropTypes.number</li>
    <li>PropTypes.object</li>
    <li>PropTypes.string</li>
    <li>PropTypes.symbol</li>
  </ul>

  <p>We can accept one of two types:</p>
  <pre><code class="language-jsx">
    PropTypes.oneOfType([
      PropTypes.string,
      PropTypes.number
    ])
  </code></pre>

  <p>We can accept one of many values:</p>
  <pre><code class="language-jsx">
    PropTypes.oneOf(['Test1', 'Test2'])
  </code></pre>

  <p>We can accept an instance of a class:</p>
  <pre><code class="language-js">
    PropTypes.instanceOf(Something)
  </code></pre>

  <p>We can accept any React node:</p>
  <pre><code class="language-js">
    PropTypes.node
  </code></pre>

  <p>or even any type at all:</p>
  <pre><code class="language-js">
    PropTypes.any
  </code></pre>

  <p>Arrays have a special syntax that we can use to accept an array of a particular type:</p>
  <pre><code class="language-js">
    PropTypes.arrayOf(PropTypes.string)
  </code></pre>

  <p>Objects, we can compose an object properties by using</p>
  <pre><code class="language-js">
    PropTypes.shape({
      color: PropTypes.string,
      fontSize: PropTypes.number
    })
  </code></pre>

  <h5 id="requiring-properties">Requiring properties</h5>
  <p>Appending <code class="language-jsx">isRequired</code> to any PropTypes option will cause React to return an error if that property is
    missing:</p>
  <pre><code class="language-js">
    PropTypes.arrayOf(PropTypes.string).isRequired,
    PropTypes.string.isRequired
  </code></pre>



  <h2 id="reactState">State</h2>
  <p>State is similar to props, but it is private and fully controlled by the component.</p>
  <p>Only Components defined as classes have some Local state feature.</p>
  <p>States are mutable. But can't be modified directlty. You need to use <code class="language-jsx">setState()</code>.</p>
  <p>State can be pass down to child component via <strong>Props</strong>. When state value change, child component will
    be re-render automatically. </p>

  <h4>Adding Local State to a Class</h4>
  <ul>
    <li>Add a class constructor that assigns the initial this.state:</li>
    <li>Use <code class="language-jsx">this.state.date</code> in the <code class="language-jsx">render()</code> method or component same as you used props.</li>
  </ul>

  <h4>Setting the default state</h4>
  <p>In the Component constructor, initialize <code class="language-jsx">this.state</code>. For example the BlogPostExcerpt component might
    have a <code class="language-jsx">clicked</code> state:</p>

  <pre><code class="language-jsx">
    class BlogPostExcerpt extends Component {
      constructor(props) {
        super(props)
        this.state = { clicked: false }
      }

      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Title&lt;/h1&gt;
            &lt;p&gt;Description&lt;/p&gt;
          &lt;/div&gt;
        )
      }
    }
  </code></pre>

  <h4>Accessing the state</h4>
  <p>The <em>clicked</em> state can be accessed by referencing <code class="language-jsx">this.state.clicked</code>:</p>
  
  <pre><code class="language-jsx">
    class BlogPostExcerpt extends Component {
      constructor(props) {
        super(props)
        this.state = { clicked: false }
      }

      render() {
        return (
          &lt;div&gt;
            &lt;h1&gt;Title&lt;/h1&gt;
            &lt;p&gt;Description&lt;/p&gt;
            &lt;p&gt;Clicked: {this.state.clicked}&lt;/p&gt;
          &lt;/div&gt;
        )
      }
    }
  </code></pre>

  <h4>Modifying the state</h4>
  <p>A state should never be mutated by using</p>

  <pre><code class="language-jsx">
    this.state.clicked = true
  </code></pre>

  <p>Instead, you should always use <code class="language-jsx">setState()</code> instead, passing it an object:</p>
  <pre><code class="language-jsx">
    this.setState({ clicked: true })
  </code></pre>

  <p>The object can contain a subset, or a superset, of the state. Only the properties you pass will be mutated, the
    ones omitted will be left in their current state.</p>

  <h4 id="why-you-should-always-use-setstate">Why you should always use <code class="language-jsx">setState()</code></h4>
  <p>The reason is that using this method, React knows that the state has changed. It will then start the series of
    events that will lead to the Component being re-rendered, along with any <strong>DOM</strong> update.</p>

  <!-- h4 id="state-is-encapsulated">State is encapsulated</h4>
  <p>A parent of a Component cannot tell if the child is stateful or stateless. Same goes for children of a
    Component.</p>

  <p>Being stateful or stateless (class-based or functional) is entirely an implementation detail that other
    components don&rsquo;t need to care about.</p-->

  <p>This leads us to Unidirectional Data Flow</p>

  <h4 id="unidirectional-data-flow">Unidirectional Data Flow</h4>
  <p>A state is always owned by one Component. Any data that&rsquo;s affected by this state can only affects
    Components below it: its children.</p>

  <p>Changing a state on a Component will never affects its parent, or its siblings, or any other Component in
    the application: just its children.</p>

  <p>This is the reason many times the state is moved up in the Components tree.</p>

  <h4>Moving the State Up in the Tree</h4>
  <p>Because of the Unidirectional Data Flow rules, if two components need to share a state, the state needs to
    be moved up to a common ancestor.</p>

  <p>Many times the closest ancestor is the best place to manage the state, but it&rsquo;s not a mandatory rule.</p>

  <p>The state is passed down to the components that need that value via props:</p>
  <pre><code class="language-jsx">
    class Converter extends React.Component {
      constructor(props) {
        super(props)
        this.state = { currency: &#x27;&#x20AC;&#x27; }
      }
    
      render() {
        return (
          &#x3C;div&#x3E;
            &#x3C;Display currency={this.state.currency} /&#x3E;
            &#x3C;CurrencySwitcher currency={this.state.currency} /&#x3E;
          &#x3C;/div&#x3E;
        )
      }
    }
  </code></pre>

  <p>The state can be mutated by a child component by passing a mutating function down as a prop:</p>

  <pre><code class="language-jsx">
    class Converter extends React.Component {
      constructor(props) {
        super(props)
        this.state = { currency: &#x27;&#x20AC;&#x27; }
      }
    
      handleChangeCurrency = event =&#x3E; {
        this.setState({ currency: this.state.currency === &#x27;&#x20AC;&#x27; ? &#x27;$&#x27; : &#x27;&#x20AC;&#x27; })
      }
    
      render() {
        return (
          &#x3C;div&#x3E;
            &#x3C;Display currency={this.state.currency} /&#x3E;
            &#x3C;CurrencySwitcher
              currency={this.state.currency}
              handleChangeCurrency={this.handleChangeCurrency}
            /&#x3E;
          &#x3C;/div&#x3E;
        )
      }
    }
    
    const CurrencySwitcher = props =&#x3E; {
      return (
        &#x3C;button onClick={props.handleChangeCurrency}&#x3E;
          Current currency is {props.currency}. Change it!
        &#x3C;/button&#x3E;
      )
    }
    
    const Display = props =&#x3E; {
      return &#x3C;p&#x3E;Current currency is {props.currency}.&#x3C;/p&#x3E;
    }
  </code></pre>

  
  
  
  <h2 id="reactPropsVsState">Props vs State</h2>
  <p>What&#39;s the difference between state and props in React?</p>
  <p>In a React component, <strong>props</strong> are variables passed to it by its parent component.
    <strong>State</strong>
    on the other hand is still variables, but directly initialized and managed by the component.</p>
  <p>The state can be initialized by props.</p>
  <p>For example, a parent component might include a child component by calling</p>
  
  <pre><code class="language-jsx">
    &lt;ChildComponent /&gt;
  </code></pre>
  
  <p>The parent can pass a prop by using this syntax:</p>
  
  <pre><code class="language-jsx">
    &lt;ChildComponent color=green /&gt;
  </code></pre>

  <p>Inside the ChildComponent constructor we could access the prop:</p>
  <pre><code class="language-jsx">class ChildComponent extends Component {
    constructor(props) {
      super(props)
        console.log(props.color)
      }
    }
  </code></pre>

  <p>and any other method in this class can reference the props using <code class="language-jsx">this.props</code>.</p>
  <p>Props can be used to set the internal state based on a prop value in the constructor, like this:</p>
  
  <pre><code class="language-jsx">
    class ChildComponent extends Component {
      constructor(props) {
        super(props)
        this.state.colorName = props.color
      }
    }
  </code></pre>
  
  <p>Of course a component can also initialize the state without looking at props.</p>
  <p>In this case there&rsquo;s nothing useful going on, but imagine doing something different based on the prop
    value,
    probably setting a state value is best.</p>
  <p>Props should never be changed in a child component, so if there&rsquo;s something going on that alters some
    variable, that variable should belong to the component state.</p>
  <p>Props are also used to allow child components to access methods defined in the parent component. This is a good way
    to centralize managing the state in the parent component, and avoid children to have the need to have their own state.
  </p>
  <p>Most of your components will just display some kind of information based on the props they received, and
    stay <strong>stateless</strong>.</p>

  

  
  <h2 id="reactHandlingEvents">Handling Events</h2>

  <p class="list-heading">Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic
    differences:</p>
  <ul>
    <li>React events are named using camelCase, rather than lowercase.</li>
    <li>With JSX you pass a function as the event handler, rather than a string.</li>
    <li> you cannot return false to prevent default behavior in React. You must call
      <code class="language-jsx">preventDefault explicitly</code>.</li>
  </ul>

  <pre><code class="language-jsx">
    // &lt;button onclick=&quot;activateLasers()&quot;&gt;
    // Activate Lasers
    // &lt;/button&gt;
    &lt;button onClick={activateLasers}&gt;
      Activate Lasers
    &lt;/button&gt;
  </code></pre>  

  <pre><code class="language-jsx">
    const CurrencySwitcher = (props) =&gt; {
      return (
        &lt;button onClick={props.handleChangeCurrency}&gt;
          Current currency is {props.currency}. Change it!
        &lt;/button&gt;
      )
    }
  </code></pre>

  <p>If you&rsquo;ve been using JavaScript for a while, this is just like plain old <strong>JavaScript
      event handlers</strong>, except that this time you&rsquo;re defining everything in JavaScript, not in your
    HTML,
    and
    you&rsquo;re passing a function, not a string.</p>
  <p>The actual event names are a little bit different because in React you use camelCase for everything, so
    <code class="language-jsx">onclick</code>
    becomes <code class="language-jsx">onClick</code>, <code class="language-jsx">onsubmit</code> becomes <code class="language-jsx">onSubmit</code>.</p>
  <p>For reference, this is old school HTML with JavaScript events mixed in:</p>

  <pre><code class="language-html">
    &lt;button onclick=&quot;handleChangeCurrency()&quot;&gt;
      ...
    &lt;/button&gt;
  </code></pre>

  <h3>Event handlers</h3>
  <p>It&rsquo;s a convention to have event handlers defined as methods on the Component class:</p>
  
  <pre><code class="language-jsx">
    class Converter extends React.Component {
      handleChangeCurrency = (event) =&gt; {
        this.setState({ currency: this.state.currency ===
          '€' ? '$' : '€' })
      }
    }
  </code></pre>

  <p>All handlers receive an event object that adheres, cross-browser, to the <strong>W3C</strong> UI Events spec</a>.
  </p>
  <h3 id="bind-this-in-methods">Bind <code class="language-jsx">this</code> in methods</h3>
  <p>Don&rsquo;t forget to bind methods. The methods of ES6 classes by default are not bound. What this means is
    that <code class="language-jsx">this</code> is not defined unless you define methods as arrow functions:</p>
  
  <pre><code class="language-jsx">
    class Converter extends React.Component {
      handleClick = (e) =&gt; { /* ... */ }
      //...
    }
  </code></pre>

  <p>when using the the property initializer syntax with Babel (enabled by default in <code class="language-jsx">create-react-app</code>),
    otherwise you need to bind it manually in the constructor:</p>
  
  <pre><code class="language-jsx">
    class Converter extends React.Component {
      constructor(props) {
        super(props)
        this.handleClick = this.handleClick.bind(this)
      }
      handleClick(e) {}
    }
  </code></pre>

  <h3 id="the-events-reference">The events reference</h3>
  <p>There are lots of events supported, here&rsquo;s a summary list.</p>
  <h4 id="clipboard">Clipboard</h4>
  <ul>
    <li>onCopy</li>
    <li>onCut</li>
    <li>onPaste</li>
  </ul>
  <h4 id="composition">Composition</h4>
  <ul>
    <li>onCompositionEnd</li>
    <li>onCompositionStart</li>
    <li>onCompositionUpdate</li>
  </ul>
  <h4 id="keyboard">Keyboard</h4>
  <ul>
    <li>onKeyDown</li>
    <li>onKeyPress</li>
    <li>onKeyUp</li>
  </ul>
  <h4 id="focus">Focus</h4>
  <ul>
    <li>onFocus</li>
    <li>onBlur</li>
  </ul>
  <h4 id="form">Form</h4>
  <ul>
    <li>onChange</li>
    <li>onInput</li>
    <li>onSubmit</li>
  </ul>
  <h4 id="mouse">Mouse</h4>
  <ul>
    <li>onClick</li>
    <li>onContextMenu</li>
    <li>onDoubleClick</li>
    <li>onDrag</li>
    <li>onDragEnd</li>
    <li>onDragEnter</li>
    <li>onDragExit</li>
    <li>onDragLeave</li>
    <li>onDragOver</li>
    <li>onDragStart</li>
    <li>onDrop</li>
    <li>onMouseDown</li>
    <li>onMouseEnter</li>
    <li>onMouseLeave</li>
    <li>onMouseMove</li>
    <li>onMouseOut</li>
    <li>onMouseOver</li>
    <li>onMouseUp</li>
  </ul>
  <h4>Selection</h4>
  <ul>
    <li>onSelect</li>
  </ul>
  <h4>Touch</h4>
  <ul>
    <li>onTouchCancel</li>
    <li>onTouchEnd</li>
    <li>onTouchMove</li>
    <li>onTouchStart</li>
  </ul>
  <h4>UI</h4>
  <ul>
    <li>onScroll</li>
  </ul>
  <h4>Mouse Wheel</h4>
  <ul>
    <li>onWheel</li>
  </ul>
  <h4>Media</h4>
  <ul>
    <li>onAbort</li>
    <li>onCanPlay</li>
    <li>onCanPlayThrough</li>
    <li>onDurationChange</li>
    <li>onEmptied</li>
    <li>onEncrypted</li>
    <li>onEnded</li>
    <li>onError</li>
    <li>onLoadedData</li>
    <li>onLoadedMetadata</li>
    <li>onLoadStart</li>
    <li>onPause</li>
    <li>onPlay</li>
    <li>onPlaying</li>
    <li>onProgress</li>
    <li>onRateChange</li>
    <li>onSeeked</li>
    <li>onSeeking</li>
    <li>onStalled</li>
    <li>onSuspend</li>
    <li>onTimeUpdate</li>
    <li>onVolumeChange</li>
    <li>onWaiting</li>
  </ul>
  <h4>Image</h4>
  <ul>
    <li>onLoad</li>
    <li>onError</li>
  </ul>
  <h4>Animation</h4>
  <ul>
    <li>onAnimationStart</li>
    <li>onAnimationEnd</li>
    <li>onAnimationIteration</li>
  </ul>
  <h4>Transition</h4>
  <ul>
    <li>onTransitionEnd</li>
  </ul>




  <h2 id="reactLifecycleEvents">Lifecycle events</h2>
  
  <p>React class components can have hooks for several lifecycle events. Hooks allow function components to access them
    too, in a different way.</p>
  <p>During the lifetime of a component, there's a series of events that gets called, and to each event you can hook and
    provide custom functionality.</p>
  
  <p class="list-heading">First, there are 3 phases in a React component lifecycle:</p>
  <ul>
    <li>Mounting</li>
    <li>Updating</li>
    <li>Unmounting</li>
  </ul>
  
  <p>Let's see those 3 phases in detail and the methods that get called for each.</p>
  
  <h3>Mounting</h3>
  <p>When mounting you have 4 lifecycle methods before the component is mounted in the DOM: the <code>constructor</code>,
    <code>getDerivedStateFromProps</code>, <code>render and componentDidMount</code>.</p>
  
  <h4>Constructor</h4>
  <p>The constructor is the first method that is called when mounting a component.</p>
  <p>You usually use the constructor to set up the initial state using <code>this.state = ...</code></p>
  
  <h4>getDerivedStateFromProps()</h4>
  <p>When the state depends on props, getDerivedStateFromProps can be used to update the state based on the props value.
  </p>
  
  <p>It was added in React 16.3, aiming to replace the componentWillReceiveProps deprecated method.</p>
  
  <p>In this method you haven't access to this as it's a static method.</p>
  
  <p>It's a pure method, so it should not cause side effects and should return the same output when called multiple times
    with the same input.</p>
  
  <p>Returns an object with the updated elements of the state (or null if the state does not change)</p>
  
  <h4>render()</h4>
  
  <p>From the render() method you return the JSX that builds the component interface.</p>
  
  <p>It's a pure method, so it should not cause side effects and should return the same output when called multiple times
    with the same input.</p>
  
  <h4>componentDidMount()</h4>
  
  <p>This method is the one that you will use to perform API calls, or process operations on the DOM.</p>
  
  <h3>Updating</h3>
  
  <p>When updating you have 5 lifecycle methods before the component is mounted in the DOM: the getDerivedStateFromProps,
    shouldComponentUpdate, render, getSnapshotBeforeUpdate and componentDidUpdate.</p>
  
  <h4>getDerivedStateFromProps()</h4>
  
  <p>See the above description for this method.</p>
  
  shouldComponentUpdate()
  
  <p>This method returns a boolean, true or false. You use this method to tell React if it should go on with the
    rerendering, and defaults to true. You will return false when rerendering is expensive and you want to have more
    control on when this happens.</p>
  
  <h4>render()</h4>
  
  <p>See the above description for this method.</p>
  
  <h4>getSnapshotBeforeUpdate()</h4>
  
  <p>In this method you have access to the props and state of the previous render, and of the current render.</p>
  
  <p>Its use cases are very niche, and it's probably the one that you will use less.</p>
  
  <h4>componentDidUpdate()</h4>
  
  <p>This method is called when the component has been updated in the DOM. Use this to run any 3rd party DOM API or call
    APIs that must be updated when the DOM changes.</p>
  
  <p>It corresponds to the componentDidMount() method from the mounting phase.</p>
  
  <h3>Unmounting</h3>
  
  <p>In this phase we only have one method, componentWillUnmount.</p>
  
  <h4>componentWillUnmount()</h4>
  
  <p>The method is called when the component is removed from the DOM. Use this to do any sort of cleanup you need to
    perform.</p>
  
  <h4>Legacy</h4>
  
  <p>If you are working on an app that uses componentWillMount, componentWillReceiveProps or componentWillUpdate, those
    were deprecated in React 16.3 and you should migrate to other lifecycle methods.</p>

  
  
  <h2 id="formHandling">Form Handling</h2>
  <p>There are two main ways of handling forms in React, which differ on a fundamental level: how data is managed.</p>
  <ul>
    <li>if the data is handled by the DOM, we call them <strong>uncontrolled components</strong></li>
    <li>if the data is handled by the components we call them <strong>controlled components</strong></li>
  </ul>
  
  <p>As you can imagine, controlled components is what you will use most of the time. The component state is the single
    source of truth, rather than the DOM. But sometimes you are forced to use uncontroller components, for example when
    using some form fields that are inherently uncontrolled because of their behavior, like the
    <code>&lt;input type=&quot;file&quot;&gt;</code> field.</p>
  
  <p>When an element state changes in a form field managed by a component, we track it using the <code
      class="language-js">onChange</code> attribute.</p>
  
  <pre><code class="language-jsx">
      class Form extends React.Component {
        constructor(props) {
          super(props)
          this.state = { username: '' }
        }
      
        handleChange(event) {}
      
        render() {
          return (
            &lt;form&gt;
              Username:
              &lt;input
                type=&quot;text&quot;
                value={this.state.username}
                onChange={this.handleChange}
              /&gt;
            &lt;/form&gt;
          )
        }
      }
    </code></pre>
  
  <p>With class components, in order to set the new state, we must bind <code>this</code> to the <code>handleChange</code>
    method, otherwise <code>this</code> is not accessible from within that method:</p>
  
  <pre><code class="language-js">class Form extends React.Component {
      constructor(props) {
        super(props)
        this.state = { username: '' }
        this.handleChange = this.handleChange.bind(this)
      }
  
      handleChange(event) {
        this.setState({ value: event.target.value })
      }
  
      render() {
        return (
          &lt;form&gt;
            &lt;input
              type=&quot;text&quot;
              value={this.state.username}
              onChange={this.handleChange}
            /&gt;
          &lt;/form&gt;
        )
      }
    }
    </code></pre>
  
  <p>Similarly, we use the <code>onSubmit</code> attribute on the form to call the <code>handleSubmit</code> method when
    the form is submitted:</p>
  
  <pre><code class="language-js">
      class Form extends React.Component {
        constructor(props) {
          super(props)
          this.state = { username: '' }
          this.handleChange = this.handleChange.bind(this)
          this.handleSubmit = this.handleSubmit.bind(this)
        }
      
        handleChange(event) {
          this.setState({ value: event.target.value })
        }
      
        handleSubmit(event) {
          alert(this.state.username)
          event.preventDefault()
        }
      
        render() {
          return (
            &lt;form onSubmit={this.handleSubmit}&gt;
              &lt;input
                type=&quot;text&quot;
                value={this.state.username}
                onChange={this.handleChange}
              /&gt;
              &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
            &lt;/form&gt;
          )
        }
      }
    </code></pre>
  
  <p>Using hooks it&rsquo;s all much simpler:</p>
  
  <pre><code class="language-js">
      const Form = props =&gt; {
        const [username, setUsername] = useState()
      
        const handleChangeUsername = e =&gt; {
          setUsername(e.target.value)
        }
      
        const handleSubmit = event =&gt; {
          alert(username)
          event.preventDefault()
        }
      
        render() {
          return (
            &lt;form onSubmit={handleSubmit}&gt;
              Username:
              &lt;input
                type=&quot;text&quot;
                value={username}
                onChange={handleChangeUsername}
              /&gt;
            &lt;/form&gt;
          )
        }
      }
    </code></pre>
  
  <p>Validation in a form can be handled in the <code>handleChange</code> method: you have access to the old value of the
    state, and the new one. You can check the new value and if not valid reject the updated value (and communicate it in
    some way to the user).</p>
  
  <p>HTML Forms are inconsistent. They have a long history, and it shows. React however makes things more consistent for
    us, and you can get (and update) fields using its <code>value</code> attribute.</p>
  
  <p>Here&rsquo;s a <code>textarea</code>, for example:</p>
  
  <pre><code class="language-html">&lt;textarea value={this.state.address} onChange={this.handleChange} /&gt;
  </code></pre>
  
  <p>The same goes for the <code>select</code> tag:</p>
  
  <pre><code class="language-html">&lt;select value=&quot;{this.state.age}&quot; onChange=&quot;{this.handleChange}&quot;&gt;
    &lt;option value=&quot;teen&quot;&gt;Less than 18&lt;/option&gt;
    &lt;option value=&quot;adult&quot;&gt;18+&lt;/option&gt;
  &lt;/select&gt;
  </code></pre>
  
  <p>Previously we mentioned the <code>&lt;input type=&quot;file&quot;&gt;</code> field. That works a bit differently.</p>
  
  <p>In this case you need to get a reference to the field by assigning the <code>ref</code> attribute to a property defined in the constructor with <code>React.createRef()</code>, and use that to get the value of it in the submit handler:</p>

  <pre><code class="language-js">
    class FileInput extends React.Component {
      constructor(props) {
        super(props)
        this.curriculum = React.createRef()
        this.handleSubmit = this.handleSubmit.bind(this)
      }

      handleSubmit(event) {
        alert(this.curriculum.current.files[0].name)
        event.preventDefault()
      }

      render() {
        return (
          &lt;form onSubmit={this.handleSubmit}&gt;
            &lt;input type=&quot;file&quot; ref={this.curriculum} /&gt;
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
          &lt;/form&gt;
        )
      }
    }
  </code></pre>
  
  <p>This is the <strong>uncontrolled components</strong> way. The state is stored in the DOM rather than in the component
    state (notice we used <code>this.curriculum</code> to access the uploaded file, and have not touched the
    <code>state</code>.</p>

  






  <h2>React concepts: declarative</h2>

  <p>What does it mean when you read that React is declarative</p>
  <p>React made its &ldquo;declarative approach&rdquo; quite popular and upfront so it permeated the frontend
    world
    along with React.</p>
  <p>It&rsquo;s really not a new concept, but React took building UIs a lot more declaratively than with HTML
    templates:</p>
  <ul>
    <li>you can build Web interfaces without even touching the DOM directly</li>
    <li>you can have an event system without having to interact with the actual DOM Events.</li>
  </ul>
  <p>The opposite of declarative is <strong>iterative</strong>. A common example of an iterative approach is
    looking up
    elements in the DOM using jQuery or DOM events. You tell the browser exactly what to do, instead of telling
    it what
    you need.</p>
  <p>The React declarative approach abstracts that for us. We just tell React we want a component to be rendered
    in a
    specific way, and we never have to interact with the DOM to reference it later.</p>
  <h2>The Virtual DOM</h2>
  <p>The Virtual DOM is a technique that React uses to optimize interacting with the browser</p>
  <p>Many existing frameworks, before React came on the scene, were directly manipulating the DOM on every
    change.</p>
  <p>First, what is the DOM?</p>
  <p>The DOM (<em>Document Object Model</em>) is a Tree representation of the page, starting from the
    <code class="language-jsx">&lt;html&gt;</code>
    tag, going down into every children, called nodes.</p>
  <p>It&rsquo;s kept in the browser memory, and directly linked to what you see in a page.
    The DOM has an API that you can use to traverse it, access every single node, filter them, modify them.</p>
  <p>The API is the familiar syntax you have likely seen many times, if you were not using the abstract API
    provided by
    jQuery and friends:</p>

  <pre><code class="language-js">
    document.getElementById(id)
    document.getElementsByTagName(name)
    document.createElement(name)
    parentNode.appendChild(node)
    element.innerHTML
    element.style.left
    element.setAttribute()
    element.getAttribute()
    element.addEventListener()
    window.content
    window.onload
    window.dump()
    window.scrollTo()
  </code></pre>
  
  <p>React keeps a copy of the DOM representation, for what concerns the React rendering: the Virtual DOM</p>
  <h4>The Virtual DOM Explained</h4>
  <p>Every time the DOM changes, the browser has to do two intensive operations: repaint (visual or content
    changes
    to
    an element that do not affects the layout and positioning relatively to other elements) and reflow
    (recalculate
    the
    layout of a portion of the page - or the whole page layout).</p>
  <p>React uses a Virtual DOM to help the browser use less resources when changes need to be done on a page.</p>
  <p>When you call <code class="language-jsx">setState()</code> on a Component, specifying a state different than the previous one,
    React
    marks that Component as <strong>dirty</strong>. This is key: React only updates when a Component changes the
    state
    explicitly.</p>
  <p>What happens next is:</p>
  <ul>
    <li>React updates the Virtual DOM relative to the components marked as dirty (with some additional checks,
      like
      triggering <code class="language-jsx">shouldComponentUpdate()</code>)</li>
    <li>Runs the diffing algorithm to reconciliate the changes</li>
    <li>Updates the real DOM</li>
  </ul>
  <h4>Why is the Virtual DOM helpful: batching</h4>
  <p>The key thing is that React batches much of the changes and performs a unique update to the real DOM, by
    changing
    all the elements that need to be changed at the same time, so the repaint and reflow the browser must perform
    to
    render the changes are executed just once.</p>

  
  
  
  <h2 id="reactContextAPI">The React Context API</h2>
  <p>The context api is a neat way to pass state across the app without having to use props.</p>

  <p>The <strong>Context API</strong> was introduced to allow you to pass state (and allow to update the state) across
    the app, without having to use props for it.</p>

  <p>The React team suggests to stick to props if you have just a few levels of children to pass, because it&rsquo;s
    still a much less complicated API than the Context API.</p>

  <p>In many cases, it enables us to avoid using Redux, simplifying a lot our apps, and also learning how to use
    React.</p>

  <p>How does it work?</p>

  <p>You create a context using <code class="language-jsx">React.createContext()</code>, which returns a Context object.:</p>

  <pre><code class="language-js">
    const {Provider, Consumer} = React.createContext()
  </code></pre>

  <p>Then you create a wrapper component that returns a <strong>Provider</strong> component, and you add as children
    all the components from which you want to access the context:</p>

  <pre><code class="language-js">
    class Container extends React.Component {
      constructor(props) {
        super(props)
        this.state = {
          something: 'hey'
        }
      }

      render() {
        return (
          &lt;Provider value={{state: this.state}}&gt;
            {this.props.children}
          &lt;/Provider&gt;
        )
      }
    }

    class HelloWorld extends React.Component {
      render() {
        return (
          &lt;Container&gt;
            &lt;Button /&gt;
          &lt;/Container&gt;
        )
      }
    }
  </code></pre>

  <p>I used Container as the name of this component because this will be a global provider. You can also create
      smaller contexts.</p>

  <p>Inside a component that&rsquo;s wrapped in a Provider, you use a <strong>Consumer</strong> component can make use
    of the context:</p>

  <pre><code class="language-js">
    class Button extends React.Component {
      render() {
        return (
          &lt;Consumer&gt;
            {(context) =&gt; (
              &lt;button&gt;{context.state.something}&lt;/button&gt;
            )}
          &lt;/Consumer&gt;
        )
      }
    }
  </code></pre>

  <p>You can also pass functions into a Provider value, and those functions will be used by the Consumer to update the
    context state:</p>

  <pre><code class="language-js">
    &lt;Provider value={{
      state: this.state,
      updateSomething: () =&gt; this.setState({something: 'ho!'})
      {this.props.children}
    &lt;/Provider&gt;

    /* ... */
    &lt;Consumer&gt;
      {(context) =&gt; (
        &lt;button onClick={context.updateSomething}&gt;{context.state.something}&lt;/button&gt;
      )}
    &lt;/Consumer&gt;
  </code></pre>

  <p>You can see this in action <a
      href="https://glitch.com/edit/#!/flavio-react-context-api-example?path=app/components/HelloWorld.jsx">in
      this Glitch</a>.</p>

  <p>You can create multiple contexts, to make your state distributed across components, yet expose it and make it
    reachable by any component you want.</p>

  <p>When using multiple files, you create the content in one file, and import it in all the places you use it:</p>

  <pre><code class="language-jsx">
    //context.js
    import React from 'react'
    export default React.createContext()


    //component1.js
    import Context from './context'
    //... use Context.Provider

    //component2.js
    import Context from './context'
    //... use Context.Consumer
  </code></pre>

  
  
  
  
  <h2 id="reactFragment">Fragment</h2>
  <p>How to use React.Fragment to create invisible HTML tags</p>
  <p>Notice how I wrapped the return values in a <code class="language-jsx">div</code>. This is because a component can only return
    one
    single element, and if you want more than one, you need to wrap it into another container tag.</p>
  <p>This however causes an unnecessary <code class="language-jsx">div</code> in the output. You can avoid this by using
    <code class="language-jsx">React.Fragment</code>:</p>
  <pre><code class="language-jsx">
    import React, { Component } from &#x27;react&#x27;

    class BlogPostExcerpt extends Component {
      render() {
        return (
          &#x3C;React.Fragment&#x3E;
            &#x3C;h1&#x3E;{this.props.title}&#x3C;/h1&#x3E;
            &#x3C;p&#x3E;{this.props.description}&#x3C;/p&#x3E;
          &#x3C;/React.Fragment&#x3E;
        )
      }
    }
  </code></pre>

  <p>which also has a very nice shorthand syntax <code class="language-jsx">&lt;&gt;&lt;/&gt;</code> that is supported only in recent
    releases (and Babel 7+):</p>

  <pre><code class="language-jsx">
    import React, { Component } from 'react'

    class BlogPostExcerpt extends Component {
      render() {
        return (
          &lt;&gt;
            &lt;h1&gt;{this.props.title}&lt;/h1&gt;
            &lt;p&gt;{this.props.description}&lt;/p&gt;
          &lt;/&gt;
        )
      }
    }
  </code></pre>

  <h2>HOW TO LOOP INSIDE REACT JSX</h2>
  <p>If you have a set of elements you need to loop upon to generate a JSX partial, you can create a loop, and then
    add
    JSX to an array:</p>

  <pre><code class="language-jsx">
    const elements = [] //..some array

    const items = []

    for (const [index, value] of elements.entries() {
      items.push(&lt;Element key={index} /&gt;)
    }
  </code></pre>

  <p>Now when rendering the JSX you can embed the <code class="language-jsx">items</code> array simply by wrapping it in curly braces:</p>

  <pre><code class="language-jsx">
    render() {
      const elements = ['one', 'two', 'three'];

      const items = []

      for (const [index, value] of elements.entries() {
        items.push(&lt;li key={index}&gt;{value}&lt;/li&gt;)
      }

      return (
        &lt;div&gt;
          {items}
        &lt;/div&gt;
      )
    }
  </code></pre>

  <p>You can do the same directly in the JSX, using <code class="language-jsx">map</code> instead of a for-of loop:</p>

  <pre><code class="language-jsx">
    render: function() {
      const elements = ['one', 'two', 'three'];
      return (
        &lt;ul&gt;
          {elements.map((value, index) =&gt; {
            return &lt;li key={index}&gt;{value}&lt;/li&gt;
          })}
        &lt;/ul&gt;
      )
    }
  </code></pre>

  
  
  
  <h2 id="reactRouter">Router</h2>

  <p>React at its core is a very simple library, and it does not dictate anything about routing.</p>

  <p>Routing in a Single Page Application is the way to introduce some features to navigating the app through links,
    which are <strong>expected</strong> in normal web applications:</p>

  <ol>
    <li>The browser should <strong>change the URL</strong> when you navigate to a different screen</li>
    <li><strong>Deep linking</strong> should work: if you point the browser to a URL, the application should
      reconstruct the same view that was presented when the URL was generated.</li>
    <li>The <strong>browser back (and forward) button</strong> should work like expected.</li>
  </ol>
  <p><strong>Routing links together your application navigation with the navigation features offered by the
      browser</strong>:
    the <strong>address bar</strong> and the <strong>navigation buttons</strong>.</p>
  <p>React Router offers a way to write your code so that <strong>it will show certain components of your app
      only if
      the route matches what you define</strong>.</p>
  <h4>Installation</h4>
  <p>With <strong>npm</strong>:</p>
  <pre><code class="language-sh">
    npm install react-router-dom
    </code></pre>
  <p><strong>Yarn</strong>:</p>
  <pre><code class="language-sh">
    yarn add react-router-dom
    </code></pre>
  <h4>Types of routes</h4>
  <p>React Router provides two different kind of routes:</p>
  <ul>
    <li><code class="language-jsx">BrowserRouter</code></li>
    <li><code class="language-jsx">HashRouter</code></li>
  </ul>
  <p>One builds classic URLs, the other builds URLs with the hash:</p>
  <pre><code class="language-js">
    https://application.com/dashboard   /* BrowserRouter */
    https://application.com/#/dashboard /* HashRouter    */
  </code></pre>
  <p>Which one to use is mainly dictated by the browsers you need to support. <code class="language-jsx">BrowserRouter</code> uses the
    <strong>History API</strong></a>, which is relatively recent, and not supported in IE9 and below. If you
    don&rsquo;t have to worry about older browsers, it&rsquo;s the recommended choice.</p>
  <h2 id="components">Components</h2>
  <p>The 3 components you will interact the most when working with React Router are:</p>
  <ul>
    <li><code class="language-jsx">BrowserRouter</code>, usually aliased as <code class="language-jsx">Router</code></li>
    <li><code class="language-jsx">Link</code></li>
    <li><code class="language-jsx">Route</code></li>
  </ul>
  <p><code class="language-jsx">BrowserRouter</code> wraps all your Route components.</p>
  <p><code class="language-jsx">Link</code> components are - as you can imagine - used to generate links to your routes</p>
  <p><code class="language-jsx">Route</code> components are responsible for showing - or hiding - the components they contain.</p>
  <h2 id="browserrouter">BrowserRouter</h2>
  <p>Here&rsquo;s a simple example of the BrowserRouter component. You import it from react-router-dom, and you
    use it
    to wrap all your app:</p>
  <pre><code class="language-jsx">
    import React from 'react'
    import ReactDOM from 'react-dom'
    import { BrowserRouter as Router } from 'react-router-dom'
    
    ReactDOM.render(
      &lt;Router&gt;
          &lt;div&gt;
            &lt;!-- --&gt;
          &lt;/div&gt;
      &lt;/Router&gt;,
      document.getElementById('app')
    )
    </code></pre>
  <p>A BrowserRouter component can only have one child element, so we wrap all we&rsquo;re going to add in a
    <code class="language-jsx">div</code>
    element.</p>
  <h4>Link</h4>
  <p>The Link component is used to trigger new routes. You import it from <code class="language-jsx">react-router-dom</code>, and you
    can
    add the Link components to point at different routes, with the <code class="language-jsx">to</code> attribute:</p>
  <pre><code class="language-jsx">
    import React from 'react'
    import ReactDOM from 'react-dom'
    import { BrowserRouter as Router, Link } from 'react-router-dom'
    
    ReactDOM.render(
      &lt;Router&gt;
          &lt;div&gt;
            &lt;aside&gt;
              &lt;Link to={`/dashboard`}&gt;Dashboard&lt;/Link&gt;
              &lt;Link to={`/about`}&gt;About&lt;/Link&gt;
            &lt;/aside&gt;
            &lt;!-- --&gt;
          &lt;/div&gt;
      &lt;/Router&gt;,
      document.getElementById('app')
    )
    </code></pre>
  <h4>Route</h4>
  <p>Now let&rsquo;s add the Route component in the above snippet to make things actually work as we want:</p>
  <pre><code class="language-jsx">
    import React from 'react'
    import ReactDOM from 'react-dom'
    import { BrowserRouter as Router, Link, Route } from 'react-router-dom'
    
    const Dashboard = () =&gt; (
      &lt;div&gt;
        &lt;h2&gt;Dashboard&lt;/h2&gt;
        ...
      &lt;/div&gt;
    )
    
    const About = () =&gt; (
      &lt;div&gt;
        &lt;h2&gt;About&lt;/h2&gt;
        ...
      &lt;/div&gt;
    )
    
    ReactDOM.render(
      &lt;Router&gt;
        &lt;div&gt;
          &lt;aside&gt;
            &lt;Link to={`/`}&gt;Dashboard&lt;/Link&gt;
            &lt;Link to={`/about`}&gt;About&lt;/Link&gt;
          &lt;/aside&gt;
    
          &lt;main&gt;
            &lt;Route exact path=&quot;/&quot; component={Dashboard} /&gt;
            &lt;Route path=&quot;/about&quot; component={About} /&gt;
          &lt;/main&gt;
        &lt;/div&gt;
      &lt;/Router&gt;,
      document.getElementById('app')
    )
    </code></pre>
  <p>Check this example on Glitch: <a
      href="https://flaviocopes-react-router-v4.glitch.me/">https://flaviocopes-react-router-v4.glitch.me/</a></p>
  <p>When the route matches <code class="language-jsx">/</code>, the application shows the <strong>Dashboard</strong> component.</p>
  <p>When the route is changed by clicking the &ldquo;About&rdquo; link to <code class="language-jsx">/about</code>, the Dashboard
    component
    is removed and the <strong>About</strong> component is inserted in the DOM.</p>
  <p>Notice the <code class="language-jsx">exact</code> attribute. Without this, <code class="language-jsx">path=&quot;/&quot;</code> would also match
    <code class="language-jsx">/about</code>,
    since <code class="language-jsx">/</code> is contained in the route.</p>
  <h4>Match multiple paths</h4>
  <p>You can have a route respond to multiple paths simply using a regex, because <code class="language-jsx">path</code> can be a
    regular
    expressions string:</p>
  <pre><code class="language-jsx">
    &lt;Route path=&quot;/(about|who)/&quot; component={Dashboard} /&gt;
    </code></pre>
  <h4>Inline rendering</h4>
  <p>Instead of specifying a <code class="language-jsx">component</code> property on <code class="language-jsx">Route</code>, you can set a <code class="language-jsx">render</code>
    prop:</p>
  <pre><code class="language-jsx">
    &lt;Route
      path=&quot;/(about|who)/&quot;
      render={() =&gt; (
        &lt;div&gt;
          &lt;h2&gt;About&lt;/h2&gt;
          ...
        &lt;/div&gt;
      )}
    /&gt;
    </code></pre>
  <h4>Match dynamic route parameter</h4>
  <p>You already saw how to use static routes like</p>
  <pre><code class="language-jsx">
    const Posts = () =&gt; (
      &lt;div&gt;
        &lt;h2&gt;Posts&lt;/h2&gt;
        ...
      &lt;/div&gt;
    )
    
    //...
    
    &lt;Route exact path=&quot;/posts&quot; component={Posts} /&gt;
    </code></pre>
  <p>Here&rsquo;s how to handle dynamic routes:</p>
  <pre><code class="language-jsx">
    const Post = ({match}) =&gt; (
      &lt;div&gt;
        &lt;h2&gt;Post #{match.params.id}&lt;/h2&gt;
        ...
      &lt;/div&gt;
    )
    
    //...
    
    &lt;Route exact path=&quot;/post/:id&quot; component={Post} /&gt;
    </code></pre>
  <p>In your Route component you can lookup the dynamic parameters in <code class="language-jsx">match.params</code>.</p>
  <p><code class="language-jsx">match</code> is also available in inline rendered routes, and this is especially useful in this case,
    because we can use the <code class="language-jsx">id</code> parameter to lookup the post data in our data source before rendering
    Post:</p>
  <pre><code class="language-jsx">
    const posts = [
      { id: 1, title: 'First', content: 'Hello world!' },
      { id: 2, title: 'Second', content: 'Hello again!' }
    ]
    
    const Post = ({post}) =&gt; (
      &lt;div&gt;
        &lt;h2&gt;{post.title}&lt;/h2&gt;
        {post.content}
      &lt;/div&gt;
    )
    
    //...
    
    &lt;Route exact path=&quot;/post/:id&quot; render={({match}) =&gt; (
      &lt;Post post={posts.find(p =&gt; p.id === match.params.id)} /&gt;
    )} /&gt;
    </code></pre>
  <h2>How to pass props to a child component via React Router</h2>
  <p>There are many solutions to pass props to a child component via <strong>React Router</strong>, and
    some you&rsquo;ll find are outdated.</p>
  <p>The most simple ever is adding the props to the Route wrapper component:</p>
  <pre><code class="language-js">
    const Index = props =&gt; &lt;h1&gt;{props.route.something}&lt;/h1&gt;

    var routes = &lt;Route path=&quot;/&quot; something={'here'} component={Index} /&gt;
    </code></pre>
  <p>But in this way you need to modify how you access props, via <code class="language-jsx">this.props.route.*</code> instead than
    the
    usual <code class="language-jsx">this.props</code>, which might or might not be acceptable.</p>
  <p>A way to fix this is to use:</p>
  <pre><code class="language-js">
      const Index = props =&gt; (
      &lt;h1&gt;{props.something}&lt;/h1&gt;
    )

    &lt;Route path=&quot;/&quot; render={() =&gt; &lt;Index something={'here'} /&gt;} /&gt;
    </code></pre>
  <h2>Learn how to use Redux</h2>
  <p>Redux is a state manager that&rsquo;s usually used along with React, but it&rsquo;s not tied to that
    library.</p>
  <p>Moving the state up in the tree works in simple cases, but in a complex app you might find you moving almost
    all
    the state up, and then down using props.</p>
  <p>React in version 16.3.0 introduced the <a href="/react/#the-context-api"><strong>Context API</strong></a>,
    which
    makes Redux redundant for the use case of accessing the state from different parts of your app, so consider
    using
    the Context API instead of Redux, unless you need a specific feature that Redux provides.</p>
  <p>Redux is a way to manage an application state, and move it to an <strong>external global store</strong>.</p>
  <p>There are a few concepts to grasp, but once you do, Redux is a very simple approach to the problem.</p>
  <h4>When should you use Redux?</h4>
  <p>Redux is ideal for medium to big apps, and you should only use it when you have trouble managing the state
    with
    the default state management of React, or the other library you use.</p>
  <p>Simple apps should not need it at all (and there&rsquo;s nothing wrong with simple apps).</p>
  <h4>Immutable State Tree</h4>
  <p>In Redux, the whole state of the application is represented by <strong>one</strong> <strong>JavaScript</strong>
    object, called <strong>State</strong> or <strong>State Tree</strong>.</p>
  <p>We call it <strong>Immutable State Tree</strong> because it is read only: it can&rsquo;t be changed
    directly.</p>
  <p>It can only be changed by dispatching an <strong>Action</strong>.</p>
  <h2 id="actions">Actions</h2>
  <p>An <strong>Action</strong> is <strong>a JavaScript object that describes a change in a minimal way</strong> (just
    with the information needed):</p>
  <pre><code class="language-js">
    {
      type: 'CLICKED_SIDEBAR'
    }

    // e.g. with more data
    {
      type: 'SELECTED_USER',
      userId: 232
    }
    </code></pre>
  <p>The only requirement of an action object is having a <code class="language-jsx">type</code> property, whose value is usually a
    string.</p>
  <h4>Actions types should be constants</h4>
  <p>In a simple app an action type can be defined as a string, as I did in the example in the previous lesson.</p>
  <p>When the app grows is best to use constants:</p>
  <pre><code class="language-js">
    const ADD_ITEM = 'ADD_ITEM'
    const action = { type: ADD_ITEM, title: 'Third item' }
    </code></pre>
  <p>and to separate actions in their own files, and import them</p>
  <pre><code class="language-js">
    import { ADD_ITEM, REMOVE_ITEM } from './actions'
    </code></pre>
  <h3 id="action-creators">Action creators</h3>
  <p><strong>Actions Creators</strong> are functions that create actions.</p>
  <pre><code class="language-js">
    function addItem(t) {
      return {
        type: ADD_ITEM,
        title: t
      }
    }
    </code></pre>
  <p>You usually run action creators in combination with triggering the dispatcher:</p>
  <pre><code class="language-js">
    dispatch(addItem('Milk'))
    </code></pre>
  <p>or by defining an action dispatcher function:</p>
  <pre><code class="language-js">
    const dispatchAddItem = i =&gt; dispatch(addItem(i))
    dispatchAddItem('Milk')
    </code></pre>
  <h2 id="reducers">Reducers</h2>
  <p>When an action is fired, something must happen, the state of the application must change.</p>
  <p>This is the job of <strong>reducers</strong>.</p>
  <h3 id="what-is-a-reducer">What is a reducer</h3>
  <p>A <strong>reducer</strong> is a <strong>pure function</strong> that calculates the next State Tree based on
    the
    previous State Tree, and the action dispatched.</p>
  <pre><code class="language-js">
    (currentState, action) =&gt; newState
    </code></pre>
  <p>A pure function takes an input and returns an output without changing the input nor anything else. Thus, a
    reducer
    returns a completely new state tree object that substitutes the previous one.</p>
  <h4>What a reducer should not do</h4>
  <p>A reducer should be a pure function, so it should:</p>
  <ul>
    <li>never mutate its arguments</li>
    <li>never mutate the state, but instead create a new one with <code class="language-jsx">Object.assign({}, ...)</code></li>
    <li>never generate side-effects (no API calls changing anything)</li>
    <li>never call non-pure functions, functions that change their output based on factors other than their input
      (e.g. <code class="language-jsx">Date.now()</code> or <code class="language-jsx">Math.random()</code>)</li>
  </ul>
  <p>There is no reinforcement, but you should stick to the rules.</p>
  <h4>Multiple reducers</h4>
  <p>Since the state of a complex app could be really wide, there is not a single reducer, but many reducers for
    any
    kind of action.</p>
  <h4>A simulation of a reducer</h4>
  <p>At its core, Redux can be simplified with this simple model:</p>
  <h5>The state</h5>
  <pre><code class="language-js">
    {
      list: [
        { title: &quot;First item&quot; },
        { title: &quot;Second item&quot; },
      ],
      title: 'Groceries list'
    }
    </code></pre>
  <h5>A list of actions</h5>
  <pre><code class="language-js">
    { type: 'ADD_ITEM', title: 'Third item' }
    { type: 'REMOVE_ITEM', index: 1 }
    { type: 'CHANGE_LIST_TITLE', title: 'Road trip list' }
    </code></pre>
  <h4 id="a-reducer-for-every-part-of-the-state">A reducer for every part of the state</h4>
  <pre><code class="language-js">
    const title = (state = '', action) =&gt; {
        if (action.type === 'CHANGE_LIST_TITLE') {
          return action.title
        } else {
          return state
        }
    }

    const list = (state = [], action) =&gt; {
      switch (action.type) {
        case 'ADD_ITEM':
          return state.concat([{ title: action.title }])
        case 'REMOVE_ITEM':
          return state.map((item, index) =&gt;
            action.index === index
              ? { title: item.title }
              : item
        default:
          return state
      }
    }
    </code></pre>
  <h5>A reducer for the whole state</h5>
  <pre><code class="language-js">
    const listManager = (state = {}, action) =&gt; {
      return {
        title: title(state.title, action),
        list: list(state.list, action),
      }
    }
    </code></pre>
  <h3>The Store</h3>
  <p>The <strong>Store</strong> is an object that:</p>
  <ul>
    <li><strong>holds the state</strong> of the app</li>
    <li><strong>exposes the state</strong> via <code class="language-jsx">getState()</code></li>
    <li>allows to <strong>update the state</strong> via <code class="language-jsx">dispatch()</code></li>
    <li>allows to (un)register as a <strong>state change listener</strong> using <code class="language-jsx">subscribe()</code></li>
  </ul>
  <p>A store is <strong>unique</strong> in the app.</p>
  <p>Here is how a store for the listManager app is created:</p>
  <pre><code class="language-js">
    import { createStore } from 'redux'
    import listManager from './reducers'
    let store = createStore(listManager)
    </code></pre>
  <h3 id="can-i-initialize-the-store-with-server-side-data">Can I initialize the store with server-side data?</h3>
  <p>Sure, <strong>just pass a starting state</strong>:</p>
  <pre><code class="language-js">
    let store = createStore(listManager, preexistingState)
    </code></pre>
  <h3 id="getting-the-state">Getting the state</h3>
  <pre><code class="language-js">
    store.getState()
    </code></pre>
  <h3 id="update-the-state">Update the state</h3>
  <pre><code class="language-js">
    store.dispatch(addItem('Something'))
    </code></pre>
  <h3 id="listen-to-state-changes">Listen to state changes</h3>
  <pre><code class="language-js">
    const unsubscribe = store.subscribe(() =&gt;
      const newState = store.getState()
    )

    unsubscribe()
    </code></pre>
  <h2 id="data-flow">Data Flow</h2>
  <p>Data flow in Redux is always <strong>unidirectional</strong>.</p>
  <p>You call <code class="language-jsx">dispatch()</code> on the Store, passing an Action.</p>
  <p>The Store takes care of passing the Action to the Reducer, generating the next State.</p>
  <p>The Store updates the State and alerts all the Listeners.</p>
  <h2>Introduction to Redux Saga</h2>
  <p>Redux Saga is a library used to handle side effects in Redux. When you fire an action something changes in
    the
    state of the app and you might need to do something that derives from this state change</p>
  <p>In an application using <a href="/redux/">Redux</a>, when you fire an action something changes in the state
    of the
    app.</p>
  <p>As this happens, you might need to do something that derives from this state change.</p>
  <p>For example you might want to:</p>
  <ul>
    <li>make a HTTP call to a server</li>
    <li>send a WebSocket event</li>
    <li>fetch some data from a <a href="/graphql/">GraphQL</a> server</li>
    <li>save something to the cache or browser local storage</li>
  </ul>
  <p>&hellip;you got the idea.</p>
  <p>Those are all things that don&rsquo;t really relate to the app state, or are async, and you need to move
    them into
    a place different than your actions or reducers (while you technically <em>could</em>, it&rsquo;s not a good
    way to
    have a clean codebase).</p>
  <p>Enter Redux Saga, a Redux middleware helping you with side effects.</p>
  <h2 id="basic-example-of-using-redux-saga">Basic example of using Redux Saga</h2>
  <p>To avoid diving into too much theory before showing some actual code, I briefly present how I solved a
    problem I
    faced when building a sample app.</p>
  <p>In a chat room, when a user writes a message I immediately show the message on the screen, to provide a
    prompt
    feedback. This is done through a <a href="/redux/#actions">Redux Action</a>:</p>
  <pre><code class="language-js">
    const addMessage = (message, author) =&gt; ({
      type: 'ADD_MESSAGE',
      message,
      author
    })
    </code></pre>
  <p>and the state is changed through a reducer:</p>
  <pre><code class="language-js">
    const messages = (state = [], action) =&gt; {
      switch (action.type) {
        case 'ADD_MESSAGE':
          return state.concat([{
            message: action.message,
            author: action.author
          }])
        default:
          return state
      }
    }
    </code></pre>
  <p>You initialize Redux Saga by first importing it, then by applying a <em>saga</em> as a middleware to the
    Redux
    Store:</p>
  <pre><code class="language-js">
    //...
    import createSagaMiddleware from 'redux-saga'
    //...
    </code></pre>
  <p>Then we create a middleware and we apply it to our newly created Redux Store:</p>
  <pre><code class="language-js">
    const sagaMiddleware = createSagaMiddleware()

    const store = createStore(
      reducers,
      applyMiddleware(sagaMiddleware)
    )
    </code></pre>
  <p>The last step is running the saga. We import it and pass it to the run method of the middleware:</p>
  <pre><code class="language-js">
    import handleNewMessage from './sagas'
    //...
    sagaMiddleware.run(handleNewMessage)
    </code></pre>
  <p>We just need to write the saga, in <code class="language-jsx">./sagas/index.js</code>:</p>
  <pre><code class="language-js">
    import { takeEvery } from 'redux-saga/effects'

    const handleNewMessage = function* handleNewMessage(params) {
      const socket = new WebSocket('ws://localhost:8989')
      yield takeEvery('ADD_MESSAGE', (action) =&gt; {
        socket.send(JSON.stringify(action))
      })
    }

    export default handleNewMessage
    </code></pre>
  <p>What this code means is: <strong>every time</strong> the <code class="language-jsx">ADD_MESSAGE</code> action fires, we send a
    message
    to the <a href="/websockets/">WebSockets</a> server, which responds in this case on <code class="language-jsx">localhost:8989</code>.
  </p>
  <p>Notice the use of <code class="language-jsx">function*</code>, which is not a normal function, but a <a href="/es6/">generator</a>.
  </p>
  <h2 id="how-it-works-behind-the-scenes">How it works behind the scenes</h2>
  <p>Being a <a href="/redux/">Redux</a> Middleware, Redux Saga can intercept Redux Actions, and inject its own
    functionality.</p>
  <p>There are a few concepts to grasp, and here are the main keywords that you&rsquo;ll want to stick in your
    head,
    altogether: <strong>saga</strong>, <strong>generator</strong>, <strong>middleware</strong>,
    <strong>promise</strong>,
    <strong>pause</strong>, <strong>resume</strong>, <strong>effect</strong>, <strong>dispatch</strong>,
    <strong>action</strong>,
    <strong>fulfilled</strong>, <strong>resolved</strong>, <strong>yield</strong>, <strong>yielded</strong>.</p>
  <p>A <strong>saga</strong> is some &ldquo;story&rdquo; that reacts to an <strong>effect</strong> that your code
    is
    causing. That might contain one of the things we talked before, like an HTTP request or some procedure that
    saves
    to the cache.</p>
  <p>We create a <strong>middleware</strong> with a list of <strong>sagas</strong> to run, which can be one or
    more,
    and we connect this middleware to the Redux store.</p>
  <p>A <strong>saga</strong> is a <strong>generator</strong> function. When a <strong>promise</strong> is run and
    <strong>yielded</strong>, the middleware <strong>suspends</strong> the <strong>saga</strong> until the
    <strong>promise</strong>
    is <strong>resolved</strong>.</p>
  <p>Once the <strong>promise</strong> is <strong>resolved</strong> the middleware <strong>resumes</strong> the
    saga,
    until the next <strong>yield</strong> statement is found, and there it is <strong>suspended</strong> again
    until
    its <strong>promise</strong> <strong>resolves</strong>.</p>
  <p>Inside the saga code, you will generate <strong>effects</strong> using a few special helper functions
    provided by
    the <code class="language-jsx">redux-saga</code> package. To start with, we can list:</p>
  <ul>
    <li><code class="language-jsx">takeEvery()</code></li>
    <li><code class="language-jsx">takeLatest()</code></li>
    <li><code class="language-jsx">take()</code></li>
    <li><code class="language-jsx">call()</code></li>
    <li><code class="language-jsx">put()</code></li>
  </ul>
  <p>When an <strong>effect</strong> is executed, the <strong>saga</strong> is <strong>paused</strong> until the
    <strong>effect</strong> is <strong>fulfilled</strong>.</p>
  <p>For example:</p>
  <pre><code class="language-js">
    import { takeEvery } from 'redux-saga/effects'

    const handleNewMessage = function* handleNewMessage(params) {
      const socket = new WebSocket('ws://localhost:8989')
      yield takeEvery('ADD_MESSAGE', (action) =&gt; {
        socket.send(JSON.stringify(action))
      })
    }

    export default handleNewMessage
    </code></pre>
  <p>When the <strong>middleware</strong> executes the <code class="language-jsx">handleNewMessage</code> saga, it <strong>stops</strong>
    at
    the <code class="language-jsx">yield takeEvery</code> instruction and <strong>waits</strong> (<em>asynchronously</em>, of course)
    until
    the <code class="language-jsx">ADD_MESSAGE</code> action is <strong>dispatched</strong>. Then it runs its callback, and the
    <strong>saga</strong>
    can <strong>resume</strong>.</p>
  <h2 id="basic-helpers">Basic Helpers</h2>
  <p>Helpers are abstractions on top of the low-level saga APIs.</p>
  <p>Let&rsquo;s introduce the most basic helpers you can use to run your effects:</p>
  <ul>
    <li><code class="language-jsx">takeEvery()</code></li>
    <li><code class="language-jsx">takeLatest()</code></li>
    <li><code class="language-jsx">take()</code></li>
    <li><code class="language-jsx">put()</code></li>
    <li><code class="language-jsx">call()</code></li>
  </ul>
  <h3 id="takeevery"><code class="language-jsx">takeEvery()</code></h3>
  <p><code class="language-jsx">takeEvery()</code>, used in some examples, is one of those helpers.</p>
  <p>In the code:</p>
  <pre><code class="language-js">
    import { takeLatest } from 'redux-saga/effects'

    function* watchMessages() {
      yield takeEvery('ADD_MESSAGE', postMessageToServer)
    }
    </code></pre>
  <p>The <code class="language-jsx">watchMessages</code> generator pauses until an <code class="language-jsx">ADD_MESSAGE</code> action fires, and <strong>every
      time</strong> it fires, it&rsquo;s going to call the <code class="language-jsx">postMessageToServer</code> function, infinitely,
    and
    concurrently (there is no need for <code class="language-jsx">postMessageToServer</code> to terminate its execution before a new
    once
    can run)</p>
  <h3 id="takelatest"><code class="language-jsx">takeLatest()</code></h3>
  <p>Another popular helper is <code class="language-jsx">takeLatest()</code>, which is very similar to <code class="language-jsx">takeEvery()</code> but
    only
    allows one function handler to run at a time, avoiding concurrency. If another action is fired when the
    handler is
    still running, it will cancel the it, and run again with the latest data available.</p>
  <p>As with <code class="language-jsx">takeEvery()</code>, the generator never stops and continues to run the effect when the
    specified
    action occurs.</p>
  <h3 id="take"><code class="language-jsx">take()</code></h3>
  <p><code class="language-jsx">take()</code> is different in that it only waits a single time. When the action it&rsquo;s waiting for
    occurs, the promise resolves and the iterator is resumed, so it can go on to the next instruction set.</p>
  <h3 id="put"><code class="language-jsx">put()</code></h3>
  <p>Dispatches an action to the Redux store. Instead of passing in the Redux store or the dispatch action to the
    saga,
    you can just use <code class="language-jsx">put()</code>:</p>
  <pre><code class="language-js">
    yield put({ type: 'INCREMENT' })
    yield put({ type: &quot;USER_FETCH_SUCCEEDED&quot;, data: data })
    </code></pre>
  <p>which returns a plain object that you can easily inspect in your tests (more on testing later).</p>
  <h3 id="call"><code class="language-jsx">call()</code></h3>
  <p>When you want to call some function in a saga, you can do so by using a yielded plain function call that
    returns a
    promise:</p>
  <pre><code class="language-js">
    delay(1000)
    </code></pre>
  <p>but this does not play nice with tests. Instead, <code class="language-jsx">call()</code> allows you to wrap that function call
    and
    returns an object that can be easily inspected:</p>
  <pre><code class="language-js">
    call(delay, 1000)
    </code></pre>
  <p>returns</p>
  <pre><code class="language-js">
    { CALL: {fn: delay, args: [1000]}}
    </code></pre>
  <h2 id="running-effects-in-parallel">Running effects in parallel</h2>
  <p>Running effects in parallel is possible using <code class="language-jsx">all()</code> and <code class="language-jsx">race()</code>, which are very
    different
    in what they do.</p>
  <h3 id="all"><code class="language-jsx">all()</code></h3>
  <p>If you write</p>
  <pre><code class="language-js">
    import { call } from 'redux-saga/effects'

    const todos = yield call(fetch, '/api/todos')
    const user = yield call(fetch, '/api/user')
    </code></pre>
  <p>the second <code class="language-jsx">fetch()</code> call won&rsquo;t be executed until the first one succeeds.</p>
  <p>To execute them in parallel, wrap them into <code class="language-jsx">all()</code>:</p>
  <pre><code class="language-js">
      import { all, call } from 'redux-saga/effects'

    const [todos, user]  = yield all([
      call(fetch, '/api/todos'),
      call(fetch, '/api/user')
    ])
    </code></pre>
  <p><code class="language-jsx">all()</code> won&rsquo;t be resolved until both <code class="language-jsx">call()</code> return.</p>
  <h3 id="race"><code class="language-jsx">race()</code></h3>
  <p><code class="language-jsx">race()</code> differs from <code class="language-jsx">all()</code> by not waiting for all of the helpers calls to return.
    It just
    waits for one to return, and it&rsquo;s done.</p>
  <p>It&rsquo;s a race to see which one finishes first, and then we forget about the other participants.</p>
  <p>It&rsquo;s typically used to cancel a background task that runs forever until something occurs:</p>
  <pre><code class="language-js">
    import { race, call, take } from 'redux-saga/effects'

    function* someBackgroundTask() {
      while(1) {
        //...
      }
    }

    yield race([
      bgTask: call(someBackgroundTask),
      cancel: take('CANCEL_TASK')
    ])
    </code></pre>
  <p>when the <code class="language-jsx">CANCEL_TASK</code> action is emitted, we stop the other task that would otherwise run
    forever.</p>
  <h2>Styled Components</h2>
  <p>Styled Components are one of the new ways to use CSS in modern JavaScript. It is the meant to be a successor
    of
    CSS Modules, a way to write CSS that&#39;s scoped to a single component, and not leak to any other element in
    the
    page</p>
  <h2 id="a-brief-history">A brief history</h2>
  <p>Once upon a time, the Web was really simple and CSS didn&rsquo;t even exist. We laid out pages using
    <strong>tables</strong>
    and frames. Good times.</p>
  <p>Then <strong>CSS</strong> came to life, and after some time it became clear that frameworks could greatly
    help
    especially in building grids and layouts, Bootstrap and Foundation playing a big part of this.</p>
  <p>Preprocessors like <strong>SASS</strong> and others helped a lot to slow down the frameworks adoption, and
    to
    better organize the code conventions like <strong>BEM</strong> and <strong>SMACSS</strong> grew in their
    usage,
    especially within teams.</p>
  <p>Conventions are not a solution to everything, and they are complex to remember, so in the last few years
    with the
    increasing adoption of <a href="/javascript/">JavaScript</a> and build processes in every frontend project,
    CSS got
    its way into JavaScript (<strong>CSS-in-JS</strong>).</p>
  <p>New tools explored new ways of doing CSS-in-JS and a few succeeded with increasing popularity:</p>
  <ul>
    <li>React Style</li>
    <li>jsxstyle</li>
    <li>Radium</li>
  </ul>
  <p>and more.</p>
  <h2 id="introducing-styled-components">Introducing Styled Components</h2>
  <p>One of the most popular of these tools is <strong>Styled Components</strong>.</p>
  <p>It is the meant to be a successor of <strong>CSS Modules</strong>, a way to write CSS that&rsquo;s scoped to
    a
    single component, and not leak to any other element in the page.</p>
  <p>(more on CSS modules <a href="https://css-tricks.com/css-modules-part-1-need/">here</a> and <a
      href="https://glenmaddern.com/articles/css-modules">here</a>)</p>
  <p>Styled Components allow you to write plain CSS in your components without worrying about class names
    collisions.</p>
  <h2 id="installation">Installation</h2>
  <p>Simply install styled-components using <a href="/npm/">npm</a> or <a href="/yarn/">yarn</a>:</p>
  <pre><code class="language-sh">
    npm install styled-components
    yarn add styled-components
    </code></pre>
  <p>That&rsquo;s it! Now all you have to do is to add this import:</p>
  <pre><code class="language-js">
    import styled from &quot;styled-components&quot;;
    </code></pre>
  <h2 id="your-first-styled-component">Your first styled component</h2>
  <p>With the <code class="language-jsx">styled</code> object imported, you can now start creating Styled Components. Here&rsquo;s the
    first
    one:</p>
  <pre><code class="language-js">
    const Button = styled.button`
      font-size: 1.5em;
      background-color: black;
      color: white;
    `;
    </code></pre>
  <p><code class="language-jsx">Button</code> is now a <a href="/react/">React</a> Component in all its greatness.</p>
  <p>We created it using a function of the styled object, called <code class="language-jsx">button</code> in this case, and passing
    some CSS
    properties in a <a href="/ecmascript/#template-literals">template literal</a>.</p>
  <p>Now this component can be rendered in our container using the normal React syntax:</p>
  <pre><code class="language-js">
    render(
      &lt;Button /&gt;
    )
    </code></pre>
  <p>Styled Components offer other functions you can use to create other components, not just <code class="language-jsx">button</code>,
    like <code class="language-jsx">section</code>, <code class="language-jsx">h1</code>, <code class="language-jsx">input</code> and many others.</p>
  <p>The syntax used, with the backtick, might be weird at first, but it&rsquo;s called <a
      href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">Tagged
      Templates</a>, it&rsquo;s plain JavaScript and it&rsquo;s a way to pass an argument to the function.</p>
  <h2 id="using-props-to-customize-components">Using props to customize components</h2>
  <p>When you pass some props to a Styled Component, it will pass them down to the <a href="/dom/">DOM</a> node
    mounted.</p>
  <p>For example here&rsquo;s how we pass the <code class="language-jsx">placeholder</code> and <code class="language-jsx">type</code> props to an
    <code class="language-jsx">input</code>
    component:</p>
    
  <pre><code class="language-js">
    const Input = styled.input`
      //...
    `;
    
    render(
      &lt;div&gt;
        &lt;Input placeholder=&quot;...&quot; type=&quot;text&quot; /&gt;
      &lt;/div&gt;
    );
    </code></pre>

  <p>This will do just what you think, inserting those props as HTML attributes.</p>
  <p>Props instead of just being blindly passed down to the <a href="/dom/">DOM</a> can also be used to customize
    a component based on the prop value. Here&rsquo;s an example:</p>

  <pre><code class="language-js">
    const Button = styled.button`
    background: ${props =&gt; props.primary ? 'black' : 'white'};
    color: ${props =&gt; props.primary ? 'white' : 'black'};
    `;
    
    render(
      &lt;div&gt;
        &lt;Button&gt;A normal button&lt;/Button&gt;
        &lt;Button&gt;A normal button&lt;/Button&gt;
        &lt;Button primary&gt;The primary button&lt;/Button&gt;
      &lt;/div&gt;
    );
  </code></pre>

  <p>Setting the <code class="language-jsx">primary</code> prop changes the color of the button.</p>
  <h2 id="extending-an-existing-styled-component">Extending an existing Styled Component</h2>
  <p>If you have one component and you want to create a similar one, just styled slightly differently, you can
    use <code class="language-jsx">extend</code>:</p>

  <pre><code class="language-js">
    const Button = styled.button`
      color: black;
      //...
    `;
    
    const WhiteButton = Button.extend`
      color: white;
    `;
    
    render(
      &lt;div&gt;
        &lt;Button&gt;A black button, like all buttons&lt;/Button&gt;
        &lt;WhiteButton&gt;A white button&lt;/WhiteButton&gt;
      &lt;/div&gt;
    );
  </code></pre>

  <h2 id="it-s-regular-css">It&rsquo;s Regular CSS</h2>
  <p>In Styled Components, you can use the CSS you already know and love. It&rsquo;s just plain CSS. It is not
    pseudo
    CSS nor inline CSS with its limitations.</p>
  <p>You can use media queries, <a href="https://tabatkins.github.io/specs/css-nesting/">nesting</a> and
    everything you
    might come up with.</p>
  <h2 id="using-vendor-prefixes">Using Vendor Prefixes</h2>
  <p>Styled Components automatically add all the vendor prefixes needed, so you don&rsquo;t need to worry about
    this
    problem.</p>
  <h2>Visual Studio Code setup for React development</h2>
  <h2>ESLint</h2>
  <p>First, we&rsquo;re going to install ESLint. ESLint is an amazing tool that helps you keep your code tiny and
    clean.</p>
  <p>Install <a href="/eslint/">ESLint</a> using the <a
      href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">ESLint
      extension</a> available on the VS Code Extensions Store.</p>
  <p>Then from the Terminal run those <a href="/yarn/">Yarn</a> commands (if you don&rsquo;t have Yarn installed
    yet,
    follow the link to my tutorial to find a short guide):</p>

  <pre><code class="language-jsx">
    yarn add babel-eslint
    yarn add eslint-config-airbnb
    yarn add eslint-plugin-jsx-a11y
    yarn add eslint-plugin-react
  </code></pre>

  <p>Now, create a <code class="language-jsx">.eslintrc.json</code> file in the root of your project, and add the following lines to
    have a
    basis ESLint configuration that works for React development, with <a href="/jsx/">JSX</a> support:</p>

  <pre><code class="language-json">
    {
      &quot;parser&quot;: &quot;babel-eslint&quot;,
      &quot;extends&quot;: &quot;airbnb&quot;,
      &quot;plugins&quot;: [&quot;react&quot;, &quot;jsx-a11y&quot;, &quot;import&quot;]
    }
  </code></pre>

  <h2 id="prettier">Prettier</h2>
  <p>The next step I suggest is to install Prettier. <a href="/prettier/">Prettier</a> is a JavaScript
    opinionated
    formatter. It&rsquo;s a great tool because it helps you standardize your codebase, and it&rsquo;s useful even
    if you code alone. In a team, it&rsquo;s super useful as it avoids differences in code styling. Simply use what
    Prettier suggests.</p>
  <p>You can install <a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">the
      Prettier VS Code extension</a> with <a href="/npm/">npm</a>:</p>

  <pre><code class="language-jsx">
    npm install -g prettier-eslint --save-dev
  </code></pre>
  <p>Next we&rsquo;re going to add a few rules to the VS Code configuration, to apply Prettier on every save, and
    integrate it with ESLint. Press <code class="language-jsx">cmd+,</code> (on Mac) and the VS Code configuration should show up.
    Enter this at the end:</p>
  
  <pre><code class="language-json">
    &quot;editor.formatOnSave&quot;: true,
    &quot;javascript.format.enable&quot;: false,
    &quot;prettier.eslintIntegration&quot;: true
  </code></pre>
</body>

</html>