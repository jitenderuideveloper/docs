<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Angular 2</title>
  <link href="../assets/prism.css" type="text/css" rel="stylesheet" media="all" />
  <link href="../assets/styles.css" type="text/css" rel="stylesheet" media="all" />
  <script src="../assets/prism.js"></script>
</head>

<body>



  <ul>
    <li>Angular CLI</li>
    <li>NgModules</li>
    <li>Components
      <ul>
        <li>class</li>
        <li>template</li>
        <li>metadata</li>
        <li>template syntax</li>
        <li>interpolation</li>
        <li>property binding</li>
        <li>event binding</li>
        <li>two way binding</li>
        <li>pipes
          <ul>
            <li>pure pipe (default)</li>
            <li>impure pipe</li>
          </ul>
        </li>
        <li>template reference variables</li>
      </ul>
    </li>
    <li>Directives
      <ul>
        <li>Structural
          <ul>
            <li>ngIf, ngSwitch, ngFor</li>
          </ul>
        </li>
        <li>Attribute
          <ul>
            <li>NgClass, NgStyle</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Component Styling
      <ul>
        <li>Class binding</li>
        <li>Style binding</li>
      </ul>
    </li>
    <li>Component Interaction - Lifecycle Methods</li>
    <li>Services
      <ul>
        <li>Depedency Injection</li>
        <li>Providing Services</li>
      </ul>
    </li>
    <li>Observables
      <ul>
        <li>Creating Observables</li>
        <li>Subscribing to Observables</li>
        <li>Executing Observables</li>
        <li>Disposing Observables</li>
        <li>Operators</li>
      </ul>
    </li>
    <li>HTTP Client
      <ul>
        <li>HttpClient</li>
        <li>Get, Post, Put, Delete</li>
        <li>Typed Response</li>
        <li>Error Handling</li>
        <li>Interceptors</li>
      </ul>
    </li>
    <li>Forms
      <ul>
        <li>Template Driven Forms
          <ul>
            <li>FormsModule</li>
            <li>NgForm</li>
            <li>NgModel</li>
            <li>NgModelGroup</li>
            <li>Tracking State & Validity</li>
            <li>Validation & Error Messages</li>
            <li>ngSubmit</li>
          </ul>
        </li>
        <li>
          <ul>Reactive Forms
            <li>ReactiveFormsModule</li>
            <li>FormControl</li>
            <li>FormGroup</li>
            <li>setValue & patchValue</li>
            <li>FormBuilder Service</li>
            <li>Validator Functions</li>
            <li>FormArray</li>
            <li>ngSubmit</li>
          </ul>
        </li>
      </ul>
    </li>
    <li>Routing
      <ul>
        <li>RouterModule</li>
        <li>Configuring Routes</li>
        <li>RouterOutlet</li>
        <li>RouterLink</li>
        <li>Wildcard Routes</li>
        <li>Redirecting Routes</li>
        <li>Route Parameters</li>
        <li>Nested Routes</li>
        <li>Relative Paths</li>
        <li>Lazy Loading Routes</li>
        <li>Route Guards</li>
      </ul>
    </li>
    <li>Animations</li>
  </ul>
  <ul>Ecosystem
    <li>State Management
      <ul>
        <li>ngRx</li>
      </ul>
    </li>
    <li>UI Library
      <ul>
        <li>Angular Material</li>
      </ul>
    </li>
    <li>Server Side Rendering
      <ul>
        <li>Angular Universal</li>
      </ul>
    </li>
    <li>Testing
      <ul>
        <li>Jasmine & Karma</li>
        <li>Protractor</li>
      </ul>
    </li>
    <li>Miscellaneous
      <ul>
        <li>i18n</li>
        <li>Accessibility</li>
      </ul>
    </li>
  </ul>

  <nav class="site-nav">
    <ul>
      <li><a href="#ngInstallation">Installation</a></li>
      <li><a href="#ngLifeCycles">Lifecycles</a></li>
      <li><a href="#ngNgModule">NgModule</a></li>
      <li><a href="#ngComponent">Component</a></li>
      <li><a href="#ngPipe">Pipe</a></li>
      <li><a href="#ngDirective">Directive</a></li>
      <li><a href="#ngService">Service & DI</a></li>
      <li><a href="#ngHttp">HTTP</a></li>
      <li><a href="#ngRouting">Routing</a></li>
      <li><a href="#ngRxjs">RxJs</a></li>
      <li><a href="#ngDirective">Directive</a></li>
      <li><a href="#ngForm">Form</a>
        <ul>
          <li><a href="#templateDriven">template-driven</a></li>
          <li><a href="#formReactive">Reactive</a></li>
        </ul>
      </li>
      <li><a href="#bootstrap4">Bootstrap 4</a></li>
      <li><a href="#materialUi">Material-ui</a></li>
    </ul>
  </nav>

  <p>Best Practices:-</p>
  <ul>
    <li>When you bootstrap with the AppComponent class (in main.ts), Angular looks for a &lt;app-root&gt; in the
      index.html,
      finds it, instantiates an instance of AppComponent, and renders it inside the &lt;app-root&gt; tag.</li>
    <li>Component should focus on presenting data and delegate data access to a service.</li>
    <li>The component plays the part of the controller/viewmodel, and the template represents the view.</li>
    <li>{{1+1}} the text between the braces is a template expression that Angular first evaluates and then converts to
      a string.</li>
  </ul>
  <pre><code class="language-js">
  ng generate module moduleName
  ng g m moduleName
  ng generate component &lt;component-name&gt;
  ng g c componentName
  ng generate directive &lt;directive-name&gt;
  ng generate service serviceName
  ng test --watch=false --source-map --code-coverage 
  </code></pre>

  <h1>Angular 2</h1>
  <p>The basic building blocks of an Angular application are NgModules, which provide a compilation context for
    components. NgModules collect related code into functional sets; an Angular app is defined by a set of NgModules.
    An app always has at least a root module that enables bootstrapping, and typically has many more feature modules.
  </p>
  <ul>
    <li>Components define views, which are sets of screen elements that Angular can choose among and modify according
      to your program logic and data.</li>
    <li>Components use services, which provide specific functionality not directly related to views. Service providers
      can be injected into components as dependencies, making your code modular, reusable, and efficient.</li>
  </ul>
  <h2 id="ngInstallation">Installation</h2>
  <pre><code class="language-js">
  npm uninstall -g typescript
  npm uninstall -g typings
  
  npm uninstall -g @angular/cli
  npm cache clean --force
  npm install -g @angular/cli@latest  
  
  npm install -g typescript
  npm install -g typings

  ng v
  ng help
  </code></pre>

  <pre><code class="language-js">
  ng new my-app
  </code></pre>

  <pre><code class="language-js">
  cd my-app
  ng serve --open
  </code></pre>

  <h2>Component</h2>
  <p>Components are the fundamental building blocks of Angular applications. They display data on the screen, listen
    for user input, and take action based on that input.</p>
  <pre><code class="language-js">
  // Include in app.module.ts file
  // import { ComponentClassName } from 'filePath';
  import { HeroesComponent } from './heroes/heroes.component';
  
  declarations: [
    HeroesComponent
  ],
  // declared in the @NgModule.declarations array
  </code></pre>

  <h3>Template Syntax</h3>

  <h4>Class binding</h4>
  <pre><code class="language-js">
  &lt;div class=&quot;special&quot; [class.special]=&quot;!isSpecial&quot;&gt;This one is not so special&lt;/div&gt;
  </code></pre>

  <h4>Style binding</h4>
  <pre><code class="language-js">
  &lt;button [style.background-color]=&quot;canSave ? 'cyan': 'grey'&quot; &gt;Save&lt;/button&gt;  
  </code></pre>

  <h4>Reference variable</h4>
  <pre><code class="language-js">
  // set Reference variable with hash #
  &lt;form (ngSubmit)=&quot;onSubmit(heroForm)&quot; #heroForm=&quot;ngForm&quot;&gt;&lt;/form&gt; 
  &lt;div [hidden]=&quot;!heroForm.form.valid&quot;&gt;{{submitMessage}}&lt;/div&gt; 
  </code></pre>
  <h3>Component Interaction</h3>
  <h4>Pass data from parent to child with input binding</h4>
  <pre><code class="language-js">
  import { Component, Input } from '@angular/core';
  export class HeroChildComponent {
    @Input() hero: type;
  }
  <h3>{{hero}}</h3>
  <app-hero-child [hero]="hero"></app-hero-child>
  export class HeroParentComponent {
    hero = "jitender";
  }  
  </code></pre>

  The double curly braces(<code>&lt;h1&gt;{{title}}&lt;/h1&gt;</code>) are Angular's interpolation binding syntax.


  <h3>Define type for Object</h3>
  <pre class="language-js"><code>
  // Define object modal in new file
  export class Hero {
    id: number;
    name: string;
  }

  // import object modal in your file
  import { Hero } from '../hero';

  // add type with colon : 
  hero: Hero = {
    id: 1,
    name: 'Windstorm'
  };
  </code></pre>

  <h3>Create mock data</h3>
  <pre><code class="language-js">
  // src/app/mock-heroes.ts
  import { Hero } from './hero';

  export const HEROES: Hero[] = [
    { id: 11, name: 'Mr. Nice' },
    { id: 12, name: 'Narco' },
    { id: 13, name: 'Bombasto' },
    { id: 14, name: 'Celeritas' },
    { id: 15, name: 'Magneta' },
    { id: 16, name: 'RubberMan' },
    { id: 17, name: 'Dynama' },
    { id: 18, name: 'Dr IQ' },
    { id: 19, name: 'Magma' },
    { id: 20, name: 'Tornado' }
  ];
  </code></pre>

  <h3>Two-way binding</h3>
  <pre class="language-js"><code>
  // It belongs to the optional FormsModule and you must import it in (app.module.ts). 
  // import { FormsModule } from '@angular/forms';
  // imports: [
    // FormsModule
  // ]   
  &lt;label&gt;name:
    &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt;
  &lt;/label&gt;
  </code></pre>

  <h3>Directive</h3>
  <pre><code class="language-js">
  &lt;li *ngFor=&quot;let hero of heroes&quot;&gt;&lt;/li&gt;
  </code></pre>

  <pre><code class="language-js">
  &lt;div *ngIf=&quot;selectedHero&quot;&gt;&lt;/div&gt;
  </code></pre>

  <h3>Event binding</h3>
  <pre><code class="language-js">
  // in component.html
  &lt;li (click)=&quot;onSelect($event)&quot;&gt;

  // in component.ts
  onSelect($event): void {
    //define task
  }
  </code></pre>
  <h2>Dependency injection</h2>
  <p>Dependency injection is an important application design pattern. Angular has its own Dependency injection
    framework, which is typically used in the design of Angular applications to increase their efficiency and
    modularity.</p>

  <p>Dependencies are services or objects that a class needs to perform its function. Dependency injection is a coding
    pattern in which a class asks for dependencies from external sources rather than creating them itself.</p>

  <p>In Angular, the Dependency injection framework provides declared dependencies to a class when that class is
    instantiated.</p>


  <pre><code class="language-js">
  // Service imports the Angular Injectable symbol and annotates the class with the @Injectable() decorator. This marks 
  // the class as one that participates in the dependency injection system.
  import { Injectable } from '@angular/core';

  @Injectable({
    providedIn: 'root',
  })
  export class HeroService {
    constructor() { }
  }  
  </code></pre>
  <p>A service registers a provider with the root injector for your service by including provider metadata in the
    @Injectable decorator. When you provide the service at the root level, Angular creates a single, shared instance of
    HeroService and injects into any class that asks for it. Registering the provider in the @Injectable metadata also
    allows Angular to optimize an app by removing the service if it turns out not to be used after all.</p>
  <h3>Injecting services</h3>
  <pre><code class="language-js">
  constructor(private heroService: HeroServic)
  </code></pre>
  <h2>Rxjs</h2>
  <h3>Observable</h3>
  <pre><code class="language-js">
  import { Observable } from 'rxjs';
  
  getHeroes(): Observable<Hero[]> {
    return of(HEROES);
  }

  getHeroes(): void {
    this.heroService.getHeroes()
    .subscribe(heroes => this.heroes = heroes);
  }
  </code></pre>

  <h2 id="ngRouting">Routing</h2>
  <pre><code class="language-js">
  // --flat puts the file in src/app instead of its own folder.
  // --module=app tells the CLI to register it in the imports array of the AppModule.
  ng generate module app-routing --flat --module=app
  </code></pre>

  <pre><code class="language-js">
  // app-routing.module.ts
  import { NgModule } from '@angular/core';
  import { RouterModule, Routes } from '@angular/router';
  
  import { DashboardComponent } from './dashboard/dashboard.component';
  import { HeroesComponent } from './heroes/heroes.component';
  import { HeroDetailComponent } from './hero-detail/hero-detail.component';
  
  const routes: Routes = [
    { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
    { path: 'dashboard', component: DashboardComponent },
    { path: 'detail/:id', component: HeroDetailComponent },
    { path: 'heroes', component: HeroListComponent, data: { title: 'Heroes List' } },
    { path: 'heroes', component: HeroesComponent }
  ];
  
  @NgModule({
    imports: [ RouterModule.forRoot(routes) ],
    exports: [ RouterModule ]
  })
  export class AppRoutingModule {}
  </code></pre>

  <pre><code class="language-js">
  // app.module.ts
  import { AppRoutingModule } from './app-routing.module';
  
  @NgModule({
    imports: [
      AppRoutingModule
    ]
  })
  </code></pre>
  <p>The RouterOutlet is a directive from the router library that is used like a component. It acts as a placeholder
    that marks the spot in the template where the router should display the components for that outlet.</p>
  <pre><code class="language-js"> 
  // Put where you want to print routing component
  &lt;router-outlet&gt;&lt;/router-outlet&gt;
  </code></pre>

  <pre><code class="language-js">  
  // Put in the navigation component
  &lt;a routerLink=&quot;/detail/{{hero.id}} &quot; routerLinkActive=&quot;active&quot; &gt;Menu1&lt;/a&gt;
  &lt;a routerLink=&quot;/detail/{{hero.id}} &quot; [routerLinkActive]=&quot;'active fluffy'&quot; &gt;Menu1&lt;/a&gt;
  &lt;li&gt;&lt;a routerLink=&quot;/detail/{{hero.id}} &quot; routerLinkActive=&quot;active&quot; &gt;Menu2&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a routerLink=&quot;/detail/{{hero.id}} &quot; routerLinkActive=&quot;active&quot; [routerLinkActiveOptions]=&quot;{ exact: true }&quot;&gt;Menu2.1&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  </code></pre>

  <h2 id="ngHttp">HTTP</h2>
  <p>HttpClient is Angular's mechanism for communicating with a remote server over HTTP.</p>
  <p>To make HttpClient available everywhere in the app, import 'HttpClientModule' inside app.module.ts file</p>
  <pre><code class="language-js">
  // import inside app.module.ts file
  import { HttpClientModule } from '@angular/common/http';   
  </code></pre>

  <pre><code class="language-js">
  // 1. step
  import { HttpClient, HttpHeaders } from '@angular/common/http';

  // 2. step
  constructor( private http: HttpClient)
  
  //3. step 
  // (this.http.get())
  // this.http.put(httpUrl, httpData, httpOptions)

  getHeroes (): Observable&lt;Hero[]&gt; {
    return this.http.get&lt;Hero[]&gt;(this.heroesUrl)
  }
  </code></pre>


  <h3>Interpolation ( {{...}} )</h3>
  <p>Interpolation is a special syntax that Angular converts into a property binding</p>
  <p>My current hero is {{JS expression}}</p>

  <h3>Expression context</h3>
  <div *ngFor="let hero of heroes">{{hero.name}}</div>
  <input #heroInput> {{heroInput.value}}

  Binding syntax
  <p>Interpolation Property (One-way from data source to view target )</p>
  <pre><code class="language-js">
  {{expression}}
  [target]="expression"
  bind-target="expression"
  </code></pre>

  <p>Event</p>
  <pre><code class="language-js">
  (target)="statement"
  on-target="statement"
  </code></pre>

  <h3>How to Reference Html element</h3>
  <pre><code class="language-js">
  <form #heroForm (ngSubmit)="onSubmit(heroForm)"> ... </form>
  </code></pre>

  <h2 id="ngLifeCycles">Lifecycles</h2>
  <figure><img src="img/lifecycle.jpg" alt="" /></figure>
  <table>
    <tr>
      <td>Lifecycle hook</td>
      <td>Purpose and Timing</td>
      <td>Use Case</td>
      <td>Differences</td>
    </tr>
    <tr>
      <td>ng OnCh anges</td>
      <td>
        <ul>
          <li>This callback function is sought after when the data-bound property variations happen for a component
            (when an input or output binding value changes) </li>
          <li>The ngOnChanges(..) gets an object that contains every @Input property of component as key and a
            SimpleChange object as according value. </li>
        </ul>
      </td>
      <td>
        <ul>
          <li>It can be utilized practically mall the components that have input. </li>
          <li>Gets invoked whenever the input value gets changed. </li>
        </ul>
      </td>
      <td>ngOnChanges vs ngDoCheck:
        <ul>
          <li>ngOnChanges is called when data-bound property has changed</li>
          <li>ngDoCheck is called when change detection runs so you can implement your custom change detection action.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>ngOnInIt</td>
      <td>
        <ul>
          <li>Called only after the first ngOnChanges, but only once. It basically fires when the component is ready for
            use when all queries (content child and view child queries) and inputs have been resolved.</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>It's the place to perform complex initializations shortly after construction. </li>
          <li>This hook initializes data for a component</li>
        </ul>
      </td>
      <td>constructor vs ngOninit:
        <ul>
          <li>Constructor is a default method of the class that is executed when the class is instantiated and ensures
            proper initialization of fields in the class and its subclasses. <strong>Should use constructor() to setup
              Dependency Injection and not </strong><strong>much else.</strong></li>
          <li>Should use ngOnlnit for all the initialization/declaration and avoid stuff to work in the constructor.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><strong>ngDoCheck</strong></td>
      <td>
        <ul>
          <li>This is fired each time anything that can trigger change detection has fired.</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Detect and act upon changes that Angular can't or won't detect on its own (mutating objects not
            reference). </li>
        </ul>
      </td>
      <td>ngOnChanges vs ngDoCheck:
        <ul>
          <li>ngOnChanges won't be triggered when we mutate a (non-immutable) JavaScript object. Instead it triggers
            only when we reference-change the data-bound input Property. </li>
          <li>We can use ngDoCheck for such scenarios, that allows us to do a very fine-grained check of which property
            on our object changed. </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>ngAfterContentlnit</td>
      <td>
        <ul>
          <li>Called after external content has been projected into the component.</li>
          <li>This method is also called when the properties get clearly demarcated as ContentChild and ContentChildren
            and are fully initialized, which means <strong>content queries like </strong>@ContentChildren <strong>and
              @ContentChild are set before the hook callback is called.</strong></li>
          <li>In the total lifecycle of a component, this hook gets <strong>call only for once.</strong></li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Do some logical work when the projection content ready or the @ContentChildren/@ContetChild is ready.
          </li>
        </ul>
      </td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ngAfterContentChecked</td>
      <td>
        <ul>
          <li><strong>It gets its call after ngAftercontentlnit and gets executed after every execution of
            </strong>ngDoCheck.<strong> </strong></li>
          <li>This hook method accomplishes its work by investigating the modification in the content of the component
            using Angular change detection apparatus, and it still performs its task even if there is not at all any
            modification. </li>
        </ul>
      </td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ngAfterViewlnit</td>
      <td>
        <ul>
          <li>This lifecycle method gets its call after ngAfterContentChecked</li>
          <li>Respond after Angular initializes the component's views and child views / the view that a directive is in.
          </li>
          <li>Called <strong><em>once </em></strong><strong>after the first </strong>ngAfterContentChecked().</li>
        </ul>
      </td>
      <td>
        <ul>
          <li>Perfect for initializing event third party library, that needs the view be composed before taking any
            action </li>
        </ul>
      </td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ngAfterViewChecked</td>
      <td>
        <ul>
          <li>This method gets its call after ngAfterViewlnit and then for every ngAfterContentChecked method. </li>
        </ul>
      </td>
      <td>
        <ul>
          <li>When something is awaited from the child component, this component van be helpful. </li>
        </ul>
      </td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>ngOnDestory</td>
      <td>
        <ul>
          <li>This lifecycle hook gets its call after Angular destroys all the components or directives. This is the
            place where you can use your clean up logic and unsubscribe from all observable and detach from event
            handlers, by doing so you can prevent memory leakage.</li>
        </ul>
      </td>
      <td>•</td>
      <td>&nbsp;</td>
    </tr>
  </table>

  <h2 id="ngNgModule">NgModule</h2>

  <p>An NgModule is a class marked by the @NgModule decorator. @NgModule takes a metadata object that describes how to
    compile a component's template and how to create an injector at runtime. It identifies the module's own components,
    directives, and pipes, making some of them public, through the exports property, so that external components can use
    them. @NgModule can also add service providers to the application dependency injectors.</p>

  <p>NgModules configure the injector and the compiler and help organize related things together.</p>

  <h3>NgModule metadata</h3>
  <p>An NgModule is defined by a class decorated with @NgModule().</p>
  <ul>
    <li>declarations: The components, directives, and pipes that belong to this NgModule.</li>
    <li>imports: Other modules whose exported classes are needed by component templates declared in this NgModule.</li>
    <li>providers: Creators of services that this NgModule contributes to the global collection of services; they
      become
      accessible in all parts of the app.</li>
    <li>bootstrap: The main application view, called the root component, which hosts all other app views. Only the root
      NgModule should set the bootstrap property.</li>
    <li>exports: The subset of declarations that should be visible and usable in the component templates of other
      NgModules.</li>
  </ul>

  <pre><code class="language-js">
  // src/app/app.module.ts (default AppModule)
  import { BrowserModule } from '@angular/platform-browser';
  import { NgModule } from '@angular/core';
  
  import { AppComponent } from './app.component';
  
  // @NgModule decorator with its metadata
  @NgModule({
    declarations: [AppComponent],
    imports: [BrowserModule],
    providers: [],
    bootstrap: [AppComponent]
  })
  export class AppModule {}
  </code></pre>


  <h2 id="ngComponent">Component</h2>
  <section>
    <p>A class with the @Component() decorator that associates it with a companion template. Together, the component
      class and template define a view. A component is a special type of directive. The @Component() decorator extends
      the @Directive() decorator with template-oriented features.</p>

    <p>An Angular component class is responsible for exposing data and handling most of the view's display and
      user-interaction logic through data binding.</p>

    <pre><code class="language-js">
    // src\app\app.component.ts
    import { Component } from '@angular/core';

    @Component({
      selector: 'app-root',
      //template: '<h1>Hello World!</h1>',
      templateUrl: './app.component.html',
      styleUrls: ['./app.component.scss'],
      //styles: ['h1 { font-weight: normal; }'],
      //providers:  [ HeroService ]
    })

    export class AppComponent {
      title = 'starter-app';
    }
    </code></pre>

    <h4>Metadata</h4>

    <p>The metadata for a component tells Angular where to get the major building blocks that it needs to create and
      present the component and its view.</p>
    <ul>
      <li>selector: A CSS selector that tells Angular to create and insert an instance of this component wherever it
        finds the corresponding tag in template HTML.</li>
      <li>template/templateUrl: The module-relative address of this component's HTML template.</li>
      <li>styles/styleUrls: contain the CSS rule declarations</li>
      <li>providers: An array of providers for services that the component requires.</li>
    </ul>

    <h3>Data binding</h3>
    <p>Data binding plays an important role in communication between a template and its component, and is also important
      for communication between parent and child components.</p>

    <p>Add binding markup to the template HTML to tell Angular how to connect both sides. Angular supports two-way data
      binding, a mechanism for coordinating the parts of a template with the parts of a component. </p>

    <p>The following diagram shows the four forms of data binding markup. Each form has a direction: to the DOM, from
      the
      DOM, or both.</p>

    <p><img src="img/databinding.png" alt="" /></p>

    <pre><code class="language-html">
  &lt;li&gt;{{hero.name}}&lt;/li&gt;
  &lt;app-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/app-hero-detail&gt;
  &lt;li (click)=&quot;selectHero(hero)&quot;&gt;&lt;/li&gt;
  &lt;input [(ngModel)]=&quot;hero.name&quot;&gt; &lt;!-- two-way data binding --&gt;
  </code></pre>

    <ul>
      <li>The <code>{{hero.name}}</code> <strong>interpolation</strong> displays the component's hero.name property
        value within the
        &lt;li&gt;
        element.</li>
      <li>The <code>[hero]</code> <strong>property binding</strong> passes the value of selectedHero from the parent
        HeroListComponent
        to the hero
        property of the child HeroDetailComponent.</li>
      <li>The <code>(click)</code> <strong>event binding</strong> calls the component's selectHero method when the user
        clicks a
        hero's
        name.</li>
    </ul>

    <p>Two-way data binding (used mainly in template-driven forms) combines property and event binding in a single
      notation. </p>

    <p>In two-way binding, a data property value flows to the input box from the component as with property binding. The
      user's changes also flow back to the component, resetting the property to the latest value, as with event binding.
    </p>

    <p>Angular processes all data bindings once for each JavaScript event cycle, from the root of the application
      component tree through all child components.</p>
    <p><img src="img/component-databinding.png" alt="" /></p>

    <p><img src="img/parent-child-binding.png" alt="" /></p>

    <h3 id="ngPipe">Pipes</h3>
    <p>A class which is preceded by the @Pipe{} decorator and which defines a function that transforms input values to
      output values for display in a view.</p>

    <p>Angular defines various pipes, such as the date pipe and currency pipe; for a complete list, see the <a
        href="https://angular.io/api?type=pipe">Pipes API list</a>. You can also define new pipes.</p>

    <p>To specify a value transformation in an HTML template, use the pipe operator (|).</p>

    <code>{{interpolated_value | pipe_name}}</code>

    <p>You can chain pipes, sending the output of one pipe function to be transformed by another pipe function. A pipe
      can also take arguments that control how it performs its transformation.</p>

    <pre><code class="language-html">
    &lt;!-- Default format: output 'Jun 15, 2015'--&gt;
    &lt;p&gt;Today is {{today | date}}&lt;/p&gt;

    &lt;!-- fullDate format: output 'Monday, June 15, 2015'--&gt;
    &lt;p&gt;The date is {{today | date:'fullDate'}}&lt;/p&gt;

    &lt;!-- shortTime format: output '9:43 AM'--&gt;
    &lt;p&gt;The time is {{today | date:'shortTime'}}&lt;/p&gt;
  </code></pre>

    <ol>
      <li>AsyncPipe </li>
      <li>CurrencyPipe </li>
      <li>DatePipe </li>
      <li>DecimalPipe </li>
      <li>I18nPluralPipe </li>
      <li>I18nSelectPipe </li>
      <li>JsonPipe </li>
      <li>KeyValuePipe </li>
      <li>LowerCasePipe </li>
      <li>PercentPipe </li>
      <li>SlicePipe </li>
      <li>TitleCasePipe </li>
      <li>UpperCasePipe</li>
    </ol>

    <h3 id="ngDirective">Directive</h3>

    <p>A class that can modify the structure of the DOM or modify attributes in the DOM and component data model. A
      directive class definition is immediately preceded by a @Directive() decorator that supplies metadata.</p>

    <p>A directive class is usually associated with an HTML element or attribute, and that element or attribute is often
      referred to as the directive itself. When Angular finds a directive in an HTML template, it creates the matching
      directive class instance and gives the instance control over that portion of the browser DOM.</p>

    <p>There are three categories of directive:</p>
    <ul>
      <li>Components use @Component() (an extension of @Directive()) to associate a template with a class.</li>
      <li>Attribute directives : modify behavior and appearance of page elements.</li>
      <li>Structural directives : modify the structure of the DOM.</li>
    </ul>

    <p>Angular supplies a number of built-in directives that begin with the ng prefix. You can also create new
      directives to implement your own functionality.</p>


    <p>A component is technically a directive. However, components are so distinctive and central to Angular
      applications
      that Angular defines the @Component() decorator, which extends the @Directive() decorator with template-oriented
      features.</p>


    <h4>Structural directives</h4>
    <p>Structural directives are responsible for HTML layout. They shape or reshape the DOM's structure, typically by
      adding, removing, and manipulating the host elements to which they are attached.</p>

    <ul>
      <li>NgIf—conditionally creates or disposes of subviews from the template.</li>
      <li>NgFor—repeat a node for each item in a list.</li>
      <li>NgSwitch—a set of directives that switch among alternative views.</li>
    </ul>

    <pre><code class="language-html">
    &lt;li *ngFor=&quot;let item of items; trackBy: trackByItems let i=index&quot;&gt;{{i + 1}} - {{item.name}}&lt;/li&gt;

    &lt;app-hero-detail *ngIf="selectedHero"&gt;&lt;/app-hero-detail&gt;

    &lt;div [ngSwitch]=&quot;currentItem.feature&quot;&gt;
      &lt;app-stout-item    *ngSwitchCase=&quot;'stout'&quot;    [item]=&quot;currentItem&quot;&gt;&lt;/app-stout-item&gt;
      &lt;app-device-item   *ngSwitchCase=&quot;'slim'&quot;     [item]=&quot;currentItem&quot;&gt;&lt;/app-device-item&gt;
      &lt;app-lost-item     *ngSwitchCase=&quot;'vintage'&quot;  [item]=&quot;currentItem&quot;&gt;&lt;/app-lost-item&gt;
      &lt;app-best-item     *ngSwitchCase=&quot;'bright'&quot;   [item]=&quot;currentItem&quot;&gt;&lt;/app-best-item&gt;
      &lt;!-- . . . --&gt;
      &lt;app-unknown-item  *ngSwitchDefault           [item]=&quot;currentItem&quot;&gt;&lt;/app-unknown-item&gt;
    &lt;/div&gt;
    </code></pre>

    <h4>Attribute directives</h4>
    <p>Attribute directives listen to and modify the behavior of other HTML elements, attributes, properties, and
      components.</p>
    <p>Many NgModules such as the RouterModule and the FormsModule define their own attribute directives. The most
      common attribute directives are as follows:</p>

    <ul>
      <li>NgClass—adds and removes a set of CSS classes.</li>
      <li>NgStyle—adds and removes a set of HTML styles.</li>
      <li>NgModel—adds two-way data binding to an HTML form element.</li>
    </ul>

    <pre><code class="language-html">
    &lt;div [ngClass]=&quot;isSpecial ? 'special' : ''&quot;&gt;This div is special&lt;/div&gt;

    &lt;div [ngStyle]=&quot;currentStyles&quot;&gt;This div is special&lt;/div&gt;

    &lt;input [(ngModel)]="hero.name"&gt;
    </code></pre>
  </section>

  <h2 id="ngService">Services</h2>

  <section>
    <h3>Create and register an injectable service</h3>

    <h4>1. Create an injectable service class</h4>

    <pre><code class="language-html">
  ng generate service shared/services
  </code></pre>

    <pre><code class="language-html">
  //services.service.ts
  import { Injectable } from '@angular/core';

  @Injectable({
    providedIn: 'root'
  })
  export class ServicesService {

    constructor() { }
  }
  </code></pre>

    <h4>2. Configure an injector with a service provider</h4>

    <ol>
      <li>In the @Injectable() decorator for the service itself.</li>
      <li>In the @NgModule() decorator for an NgModule.</li>
      <li>In the @Component() decorator for a component.</li>
    </ol>

    <h5>Injecting services</h5>
    <pre><code class="language-html">
  // src/app/heroes/hero-list.component
  import { Component } from '@angular/core';
  import { Hero } from './hero';
  import { HeroService } from './hero.service';

  @Component({
    selector: 'app-hero-list',
    template: `
      <div *ngFor="let hero of heroes">
        {{hero.id}} - {{hero.name}}
      </div>
    `
  })
  export class HeroListComponent {
    heroes: Hero[];

    constructor(heroService: HeroService) {
      this.heroes = heroService.getHeroes();
    }
  }
  </code></pre>





    <p>Angular distinguishes components from services to increase modularity and reusability. By separating a
      component's
      view-related functionality from other kinds of processing, you can make your component classes lean and efficient.
    </p>

    <p>A component can delegate certain tasks to services, such as fetching data from the server, validating user input,
      or logging directly to the console. By defining such processing tasks in an injectable service class, you make
      those tasks available to any component. </p>
    <p>To define a class as a service in Angular, use the @Injectable() decorator to provide the metadata that allows
      Angular to inject it into a component as a dependency.</p>
    <p>Use the @Injectable() decorator to indicate that a component or other class (such as another service, a pipe, or
      an
      NgModule) has a dependency.</p>

    <ul>
      <li>The <em>injector</em> is the main mechanism. Angular creates an application-wide injector for you during the
        bootstrap
        process, and additional injectors as needed. You don't have to create injectors.</li>
      <li>An injector creates dependencies, and maintains a container of dependency instances that it reuses if
        possible.
      </li>
      <li>A provider is an object that tells an injector how to obtain or create a dependency.</li>
    </ul>
    <p>For any dependency that you need in your app, you must register a provider with the app's injector, so that the
      injector can use the provider to create new instances.</p>
    <p>When Angular creates a new instance of a component class, it determines which services or other dependencies that
      component needs by looking at the constructor parameter types. For example, the constructor of HeroListComponent
      needs HeroService.</p>

    <pre><code class="language-js">
  constructor(private service: HeroService) { }
  </code></pre>

    <p>When Angular discovers that a component depends on a service, it first checks if the injector has any existing
      instances of that service. If a requested service instance doesn't yet exist, the injector makes one using the
      registered provider, and adds it to the injector before returning the service to Angular.</p>
    <p>When all requested services have been resolved and returned, Angular can call the component's constructor with
      those services as arguments.</p>
    <p>The process of HeroService injection looks something like this.</p>
    <p><img src="img/injector-injects.png" alt="" /></p>

    <h3>Providing services</h3>
    <p>You must register at least one provider of any service you are going to use. The provider can be part of the
      service's own metadata, making that service available everywhere, or you can register providers with specific
      modules or components. You register providers in the metadata of the service (in the
      <strong>@Injectable()</strong>
      decorator), or in the <strong>@NgModule()</strong> or <strong>@Component()</strong> metadata</p>
    <ol>
      <li>By default, the Angular CLI command ng generate service registers a provider with the root injector for your
        service by including provider metadata in the @Injectable() decorator.
        <pre><code class="language-js">
      @Injectable({
        providedIn: 'root',
       })
    </code></pre>
        <p>When you provide the service at the root level, Angular creates a single, shared instance of HeroService and
          injects it into any class that asks for it. Registering the provider in the @Injectable() metadata also allows
          Angular to optimize an app by removing the service from the compiled app if it isn't used.</p>
      </li>

      <li>When you register a provider with a specific NgModule, the same instance of a service is available to all
        components in that NgModule.
        <pre><code class="language-js">
      @NgModule({
        providers: [
        BackendService,
        Logger
        ],
        ...
      })
      </code></pre>
      </li>
      <li>When you register a provider at the component level, you get a new instance of the service with each new
        instance of that component.
        <pre><code class="language-js">
    @Component({
      selector:    'app-hero-list',
      templateUrl: './hero-list.component.html',
      providers:  [ HeroService ]
    })
    </code></pre>
      </li>
    </ol>
  </section>

  <h2 id="ngForm">Form</h2>
  <p>Angular provides two different approaches to handling user input through forms: reactive and template-driven.
    Reactive and template-driven forms process and manage form data differently. Each offers different advantages.</p>
  <ul>
    <li><strong>Reactive</strong> forms are more robust: they're more scalable, reusable, and testable. If forms are a
      key part of your
      application, or you're already using reactive patterns for building your application, use reactive forms.</li>
    <li><strong>Template-driven</strong> forms are useful for adding a simple form to an app, such as an email list
      signup form. They're
      easy to add to an app, but they don't scale as well as reactive forms.</li>
  </ul>
  <h3>Key differences</h3>
  <p>The table below summarizes the key differences between reactive and template-driven forms.</p>

  <table>
    <thead>
      <tr>
        <th></th>
        <th>Reactive</th>
        <th>Template-driven</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Setup (form model)</td>
        <td>More explicit, created in component class</td>
        <td>Less explicit, created by directives</td>
      </tr>
      <tr>
        <td>Data model</td>
        <td>Structured</td>
        <td>Unstructured</td>
      </tr>
      <tr>
        <td>Predictability</td>
        <td>Synchronous</td>
        <td>Asynchronous</td>
      </tr>
      <tr>
        <td>Form validation</td>
        <td>Functions</td>
        <td>Directives</td>
      </tr>
      <tr>
        <td>Mutability</td>
        <td>Immutable</td>
        <td>Mutable</td>
      </tr>
      <tr>
        <td>Scalability</td>
        <td>Low-level API access</td>
        <td>Abstraction on top of APIs</td>
      </tr>
    </tbody>
  </table>

  <h3>Common foundation</h3>
  <ul>
    <li><strong>FormControl</strong> tracks the value and validation status of an individual form control.</li>
    <li><strong>FormGroup</strong> tracks the same values and status for a collection of form controls.</li>
    <li><strong>FormArray</strong> tracks the same values and status for an array of form controls.</li>
    <li><strong>ControlValueAccessor</strong> creates a bridge between Angular FormControl instances and native DOM
      elements.</li>
  </ul>

  <h3>Form model setup</h3>
  <p>Reactive and template-driven forms both use a form model to track value changes between Angular forms and form
    input elements.</p>
  <ul>
    <li>In reactive forms, the form model is the source of truth. The form model is the FormControl instance.</li>
    <li>In template-driven forms, the source of truth is the template.</li>
  </ul>
  <h4>Setup in reactive forms</h4>
  <p>With reactive forms, the form model is explicitly defined in the component class. The reactive form directive (in
    this case, FormControlDirective) then links the existing FormControl instance to a specific form element in the
    view using a value accessor (ControlValueAccessor instance).</p>
  <pre><code class="language-js">
  import { Component } from '@angular/core';
  import { FormControl } from '@angular/forms';
    
  @Component({
    selector: 'app-reactive-favorite-color',
    template: `
      Favorite Color: &lt;input type=&quot;text&quot; [formControl]=&quot;favoriteColorControl&quot;&gt;
    `
  })
  export class FavoriteColorComponent {
    favoriteColorControl = new FormControl('');
  }  
  </code></pre>
  <h5>Data flow in reactive forms</h5>
  <p>In reactive forms each form element in the view is directly linked to a form model (FormControl instance). Updates
    from the view to the model and from the model to the view are synchronous and aren't dependent on the UI rendered.
    The diagrams below use the same favorite color example to demonstrate how data flows when an input field's value is
    changed from the view and then from the model.</p>

  <p>The steps below outline the data flow from view to model.</p>
  <figure><img src="img/dataflow-reactive-forms-vtm.png" alt="" /></figure>
  <ol>
    <li>
      The user types a value into the input element, in this case the favorite color Blue.</li>
    <li>The form input element emits an "input" event with the latest value.</li>
    <li>The control value accessor listening for events on the form input element immediately relays the new value to
      the FormControl instance.</li>
    <li>The FormControl instance emits the new value through the valueChanges observable.</li>
    <li>Any subscribers to the valueChanges observable receive the new value.</li>
  </ol>
  <p>The steps below outline the data flow from model to view.</p>
  <figure><img src="img/dataflow-reactive-forms-mtv.png" alt="" /></figure>
  <ol>
    <li>The user calls the favoriteColorControl.setValue() method, which updates the FormControl value.</li>
    <li>The FormControl instance emits the new value through the valueChanges observable.</li>
    <li>Any subscribers to the valueChanges observable receive the new value.</li>
    <li>The control value accessor on the form input element updates the element with the new value.</li>
  </ol>
  <h4>Setup in template-driven forms</h4>
  <p>The template-driven form directive NgModel is responsible for creating and managing the FormControl instance for a
    given form element. </p>
  <pre><code class="language-js">
  import { Component } from '@angular/core';

  @Component({
    selector: 'app-template-favorite-color',
    template: `
      Favorite Color: &lt;input type=&quot;text&quot; [(ngModel)]=&quot;favoriteColor&quot;&gt;
    `
  })
  export class FavoriteColorComponent {
    favoriteColor = '';
  }  
  </code></pre>

  <p>Reactive forms provide a model-driven approach to handling form inputs whose values change over time. Reactive
    forms use an explicit and immutable approach to managing the state of a form at a given point in time. Each change
    to the form state returns a new state, which maintains the integrity of the model between changes. Reactive forms
    are built around observable streams, where form inputs and values are provided as streams of input values, which
    can be accessed synchronously.</p>

  <ol>
    <li>Registering the reactive forms module</li>
    <li>Import the FormControl class into your component and create a new instance of the form control to save as a
      class property.</li>
    <li>Registering the control in the template by using the <code>formControl</code> binding provided by
      <code>FormControlDirective</code>
      included in <code>ReactiveFormsModule</code>.
    </li>
  </ol>

  <pre><code class="language-js">
  import { ReactiveFormsModule } from '@angular/forms';

  @NgModule({
    imports: [
      ReactiveFormsModule
    ],
  })
  </code></pre>
  <pre><code class="language-js">
  import { Component } from '@angular/core';
  import { FormControl } from '@angular/forms';
  
  @Component({
    selector: 'app-name-editor',
    templateUrl: './name-editor.component.html',
    styleUrls: ['./name-editor.component.css']
  })
  export class NameEditorComponent {
    name = new FormControl('');
  }
  </code></pre>
  <pre><code class="language-js">
  &lt;label&gt; Name:  &lt;input type=&quot;text&quot; [formControl]=&quot;name&quot;&gt; &lt;/label&gt;
  </code></pre>

  <h2 id="formReactive">Reactive</h2>
  <p>Reactive forms provide a model-driven approach to handling form inputs whose values change over time.</p>

  <h3>Introduction to reactive forms</h3>
  <p>Reactive forms use an explicit and immutable approach to managing the state of a form at a given point in time.
    Each change to the form state returns a new state, which maintains the integrity of the model between changes.
    Reactive forms are built around observable streams, where form inputs and values are provided as streams of input
    values, which can be accessed synchronously.</p>

  <p>Reactive forms differ from template-driven forms in distinct ways. Reactive forms provide more predictability with
    synchronous access to the data model, immutability with observable operators, and change tracking through
    observable streams. If you prefer direct access to modify data in your template, template-driven forms are less
    explicit because they rely on directives embedded in the template, along with mutable data to track changes
    asynchronously.</p>

  <h3>Simple Setup</h3>
  <p>This section describes how to add a single form control. </p>

  <p>1. To use reactive forms, import ReactiveFormsModule from the @angular/forms package and add it to your NgModule's
    imports array.</p>

  <pre><code class="language-js">
  //src/app/app.module.ts 
  import { ReactiveFormsModule } from '@angular/forms';

  @NgModule({
    imports: [
      // other imports ...
      ReactiveFormsModule
    ],
  })
  export class AppModule { }
  </code></pre>

  <p>2. To register a single form control, import the FormControl class into your component and create a new instance
    of the form control to save as a class property.</p>

  <pre><code class="language-js">
  //src/app/name-editor/name-editor.component.ts
  import { Component } from '@angular/core';
  import { FormControl } from '@angular/forms';
  
  @Component({
    selector: 'app-name-editor',
    templateUrl: './name-editor.component.html',
    styleUrls: ['./name-editor.component.css']
  })
  export class NameEditorComponent {
    name = new FormControl('');
  }
  </code></pre>

  <p>3. After you create the control in the component class, you must associate it with a form control element in the
    template. Update the template with the form control using the formControl binding provided by FormControlDirective
    included in ReactiveFormsModule.</p>

  <pre><code class="language-js">
  &lt;label&gt;
  Name:
  &lt;input type=&quot;text&quot; [formControl]=&quot;name&quot;&gt;
  &lt;/label&gt;
  </code></pre>

  <p>4. How to display</p>
  <pre><code class="language-js">
  &lt;p&gt;
  Value: {{ name.value }}
  &lt;/p&gt;
  </code></pre>

  <p>5. Replacing a form control value</p>
  <p>A form control instance provides a setValue() method that updates the value of the form control and validates the
    structure of the value provided against the control's structure.</p>

  <pre><code class="language-js">
  updateName() {
    this.name.setValue('Nancy');
  }
  </code></pre>

  <h3>Grouping form controls</h3>
  <p>Step 1: import the FormGroup and FormControl classes from the @angular/forms package and Creating a FormGroup
    instance</p>

  <pre><code class="language-js">
  import { Component } from '@angular/core';
  import { FormGroup, FormControl } from '@angular/forms';
    
  @Component({
    selector: 'app-profile-editor',
    templateUrl: './profile-editor.component.html',
    styleUrls: ['./profile-editor.component.css']
  })
  export class ProfileEditorComponent {
    profileForm = new FormGroup({
      firstName: new FormControl(''),
      lastName: new FormControl(''),
    });
  }
  </code></pre>
  <p>The individual form controls are now collected within a group. A FormGroup instance provides its model value as an
    object reduced from the values of each control in the group. A form group instance has the same properties (such as
    value and untouched) and methods (such as setValue()) as a form control instance.</p>

  <p>Step 2: Associating the FormGroup model and view</p>
  <pre><code class="language-js">
  &lt;form [formGroup]=&quot;profileForm&quot;&gt;

  &lt;label&gt;
    First Name:
    &lt;input type=&quot;text&quot; formControlName=&quot;firstName&quot;&gt;
  &lt;/label&gt;

  &lt;label&gt;
    Last Name:
    &lt;input type=&quot;text&quot; formControlName=&quot;lastName&quot;&gt;
  &lt;/label&gt;

  &lt;/form&gt;
  </code></pre>

  <h3>Saving form data</h3>
  <pre><code class="language-js">
  &lt;form [formGroup]=&quot;profileForm&quot; (ngSubmit)=&quot;onSubmit()&quot;&gt;

  onSubmit() {
    // TODO: Use EventEmitter with form value
    console.warn(this.profileForm.value);
  }
  
  &lt;button type=&quot;submit&quot; [disabled]=&quot;!profileForm.valid&quot;&gt;Submit&lt;/button&gt;
  </code></pre>

  <h3>Creating nested form groups</h3>
  <ol>
    <li>Step 1: Creating a nested group <br />
      <pre><code class="language-js">
  import { Component } from '@angular/core';
  import { FormGroup, FormControl } from '@angular/forms';
  
  @Component({
    selector: 'app-profile-editor',
    templateUrl: './profile-editor.component.html',
    styleUrls: ['./profile-editor.component.css']
  })
  export class ProfileEditorComponent {
    profileForm = new FormGroup({
      firstName: new FormControl(''),
      lastName: new FormControl(''),
      address: new FormGroup({
        street: new FormControl(''),
        city: new FormControl(''),
        state: new FormControl(''),
        zip: new FormControl('')
      })
    });
  }  
  </code></pre>
    </li>

    <li>Step 2: Grouping the nested form in the template<br />
      <pre><code class="language-js">
  &lt;div formGroupName=&quot;address&quot;&gt;
  &lt;h3&gt;Address&lt;/h3&gt;
  &lt;label&gt; Street:
    &lt;input type=&quot;text&quot; formControlName=&quot;street&quot;&gt;
  &lt;/label&gt;
  &lt;label&gt; City:
    &lt;input type=&quot;text&quot; formControlName=&quot;city&quot;&gt;
  &lt;/label&gt;
  &lt;label&gt; State:
    &lt;input type=&quot;text&quot; formControlName=&quot;state&quot;&gt;
  &lt;/label&gt;
  &lt;label&gt; Zip Code:
    &lt;input type=&quot;text&quot; formControlName=&quot;zip&quot;&gt;
  &lt;/label&gt;
  &lt;/div&gt;    
  </code></pre>
    </li>
  </ol>
  <h3>Partial model updates</h3>
  <p>When updating the value for a form group instance that contains multiple controls, you may only want to update
    parts of the model.</p>
  <p>There are two ways to update the model value:</p>
  <ul>
    <li>Use the setValue() method to set a new value for an individual control. The setValue() method strictly adheres
      to the structure of the form group and replaces the entire value for the control.</li>
    <li>Use the patchValue() method to replace any properties defined in the object that have changed in the form
      model.</li>
  </ul>
  <p>The strict checks of the setValue() method help catch nesting errors in complex forms, while patchValue() fails
    silently on those errors.</p>
  <pre><code class="language-js">
  updateProfile() {
    this.profileForm.patchValue({
      firstName: 'Nancy',
      address: {
        street: '123 Drew Street'
      }
    });
  }
  </code></pre>

  <h3>Generating form controls with FormBuilder</h3>
  <p>Creating form control instances manually can become repetitive when dealing with multiple forms. The FormBuilder
    service provides convenient methods for generating controls.</p>
  <h4>Step 1: Importing the FormBuilder class</h4>
  <pre><code class="language-js">
  import { FormBuilder } from '@angular/forms';
  </code></pre>

  <h4>Step 2: Injecting the FormBuilder service</h4>
  <p>The FormBuilder service is an injectable provider that is provided with the reactive forms module. Inject this
    dependency by adding it to the component constructor.</p>
  <pre><code class="language-js">
  constructor(private fb: FormBuilder) { }
  </code></pre>

  <h4>Step 3: Generating form controls</h4>
  <p>The FormBuilder service has three methods: control(), group(), and array(). These are factory methods for
    generating instances in your component classes including form controls, form groups, and form arrays.</p>

  <pre><code class="language-js">
  import { Component } from '@angular/core';
  import { FormBuilder } from '@angular/forms';
    
  @Component({
    selector: 'app-profile-editor',
    templateUrl: './profile-editor.component.html',
    styleUrls: ['./profile-editor.component.css']
  })
  export class ProfileEditorComponent {
    profileForm = this.fb.group({
      firstName: [''],
      lastName: [''],
      address: this.fb.group({
        street: [''],
        city: [''],
        state: [''],
        zip: ['']
      }),
    });
    
    constructor(private fb: FormBuilder) { }
  }
  </code></pre>

  <h3>Dynamic controls using form arrays</h3>
  <p>FormArray is an alternative to FormGroup for managing any number of unnamed controls. You don't need to define a
    key for each control by name, so this is a great option if you don't know the number of child values in advance.</p>
  <h4>Step 1: Importing the FormArray class</h4>
  <pre><code class="language-js">
  import { FormArray } from '@angular/forms';
  </code></pre>

  <h4>Step 2: Defining a FormArray control</h4>
  <p>You can initialize a form array with any number of controls, from zero to many, by defining them in an array. Add
    an aliases property to the form group instance for profileForm to define the form array.</p>
  <p>Use the FormBuilder.array() method to define the array, and the FormBuilder.control() method to populate the array
    with an initial control.</p>
  <pre><code class="language-js">
  profileForm = this.fb.group({
    firstName: ['', Validators.required],
    lastName: [''],
    address: this.fb.group({
      street: [''],
      city: [''],
      state: [''],
      zip: ['']
    }),
    aliases: this.fb.array([
      this.fb.control('')
    ])
  });
  </code></pre>

  <h4>Step 3: Accessing the FormArray control</h4>
  <p>Use the getter syntax to create an aliases class property to retrieve the alias's form array control from the
    parent form group.</p>
  <pre><code class="language-js">
  get aliases() {
    return this.profileForm.get('aliases') as FormArray;
  }
  </code></pre>

  <p>Define a method to dynamically insert an alias control into the alias's form array. The FormArray.push() method
    inserts the control as a new item in the array.</p>
  <pre><code class="language-js">
  addAlias() {
    this.aliases.push(this.fb.control(''));
  }
  </code></pre>

  <h4>Step 4: Displaying the form array in the template</h4>
  <p>To attach the aliases from your form model, you must add it to the template. Similar to the formGroupName input
    provided by FormGroupNameDirective, formArrayName binds communication from the form array instance to the template
    with FormArrayNameDirective.</p>

  <h3>Simple form validation</h3>
  <h4>Step 1: Importing a validator function</h4>

  <pre><code class="language-js">
  import { Validators } from '@angular/forms';
  </code></pre>

  <h4>Step 2: Making a field required</h4>

  <pre><code class="language-js">
  profileForm = this.fb.group({
    firstName: ['', Validators.required],
    lastName: [''],
    address: this.fb.group({
      street: [''],
      city: [''],
      state: [''],
      zip: ['']
    }),
  });
  </code></pre>

  <h4>Displaying form status</h4>
  <pre><code class="language-js">
  &lt;p&gt; Form Status: {{ profileForm.status }} &lt;/p&gt;
  </code></pre>


  <h2>Form</h2>
  <h3>Setup in reactive form</h3>
  <p>Simple</p>
  <ol>
    <li>Register the reactive forms module in app.module.ts <br />
      <pre><code class="language-js">
      import { ReactiveFormsModule } from '@angular/forms'; <br />
      @NgModule({ 
        imports: [ 
          ReactiveFormsModule 
        ] 
      })
      </code></pre>
    </li>
    <li>To register a single form control in app.component.ts, import the FormControl class and create a new instance of
      FormControl to save as a class property. <br />
      <pre><code class="language-js">
      import { FormControl } from '@angular/forms'; <br />
      
      export class NameEditorComponent {
        name = new FormControl('');
      }
      </code></pre>
    </li>
    <li>Displaying a form control value and Replacing a form control value in component.ts file<br />
      <pre><code class="language-js">
      this.name.value;<br />
      this.name.setValue('Nancy');
      </code></pre>
    </li>
    <li>Register the control in the html template. <br />
      <pre><code class="language-js">
        [formControl]="name"
      </code></pre>
    </li>
  </ol>

  <pre><code class="language-js">
  // simple-reactive-form.component.ts
  import { Component } from '@angular/core';
  import { FormControl } from '@angular/forms';

  @Component({
    selector: 'app-name-editor',
    templateUrl: './name-editor.component.html',
    styleUrls: ['./name-editor.component.css']
  })
  export class NameEditorComponent {
    name = new FormControl('');

    updateName(): void {
      this.name.setValue('Nancy');
    }
  }
  </code></pre>

  <pre><code class="language-js">
  // simple-reactive-form.component.html
  &lt;label&gt; Name: &lt;input type=&quot;text&quot; [formControl]=&quot;name&quot; /&gt; &lt;/label&gt;

  &lt;p&gt;Value: {{ name.value }}&lt;/p&gt;
  
  &lt;p&gt;&lt;button (click)=&quot;updateName()&quot;&gt;Update Name&lt;/button&gt;&lt;/p&gt;
  </code></pre>

  <h3>Grouping form controls </h3>
  <ol>
    <li>Create a FormGroup instance.<br />
      <pre><code class="language-js">
    import { FormGroup, FormControl } from '@angular/forms';

    profileForm = new FormGroup({
      firstName: new FormControl(''),
      lastName: new FormControl(''),
    });
    </code></pre>
    </li>

    <li>Associate the FormGroup model and view.<br />
      <pre><code class="language-js">
    &lt;form [formGroup]=&quot;profileForm&quot;&gt;
    &lt;input type=&quot;text&quot; formControlName=&quot;firstName&quot;&gt;
    </code></pre>
    </li>

    <li>Save the form data. <br />
      <pre><code class="language-js">
    &lt;form [formGroup]=&quot;profileForm&quot; (ngSubmit)=&quot;onSubmit()&quot;&gt;&lt;/form&gt;

    onSubmit() {
      // TODO: Use EventEmitter with form value
      console.warn(this.profileForm.value);
    }

    &lt;button type=&quot;submit&quot; [disabled]=&quot;!profileForm.valid&quot;&gt;Submit&lt;/button&gt;
    </code></pre>
    </li>

    <li>Updating parts of the data model <br />
      <pre><code class="language-js">
    this.profileForm.patchValue({
      firstName: 'Nancy',
      address: {
        street: '123 Drew Street'
      }
    });
    </code></pre>
    </li>
  </ol>

  <h4>Creating nested form groups</h4>
  <ol>
    <li>
      <pre><code class="language-js">
    Create a nested group.
    import { FormGroup, FormControl } from '@angular/forms';

    profileForm = new FormGroup({
      firstName: new FormControl(''),
      lastName: new FormControl(''),
      address: new FormGroup({
        street: new FormControl(''),
        city: new FormControl(''),
        state: new FormControl(''),
        zip: new FormControl('')
      })
    });
    </code></pre>
    </li>

    <li>Group the nested form in the template.
      <pre><code class="language-js">
    &lt;div formGroupName=&quot;address&quot;&gt;
      &lt;input type=&quot;text&quot; formControlName=&quot;street&quot;&gt;
      &lt;input type=&quot;text&quot; formControlName=&quot;city&quot;&gt;
    </code></pre>
    </li>

  </ol>


  <h4>Using the FormBuilder service to generate controls ( using the form builder to creating the instances manually.)
  </h4>
  <ol>
    <li>Import the FormBuilder class and Inject the FormBuilder service <br />
      <pre><code class="language-js">
        import { FormBuilder } from '@angular/forms';

        constructor(private fb: FormBuilder) { }
        </code></pre>
    </li>

    <li>Inject the FormBuilder service.<br />
      <pre><code class="language-js">
      profileForm = this.fb.group({
        firstName: [''],
        lastName: [''],
        address: this.fb.group({
          street: [''],
          city: [''],
          state: [''],
          zip: ['']
        })
      })
      </code></pre>
    </li>

    <li>Generate the form contents.</li>
  </ol>

  <h4>Validating form input</h4>
  <ol>
    <li>Import a validator function in your form component. <br />
      <pre><code class="language-js">
      import { Validators } from '@angular/forms';
      </code></pre>
    </li>
    <li>Add the validator to the field in the form and display form status. <br />
      <pre><code class="language-js">
      profileForm = this.fb.group({
        firstName: ['', Validators.required],
        lastName: [''],
        address: this.fb.group({
          street: [''],
          city: [''],
          state: [''],
          zip: ['']
        }),
      });
      
      &lt;input type=&quot;text&quot; formControlName=&quot;firstName&quot; required&gt;

      &lt;p&gt; Form Status: {{ profileForm.status }} &lt;/p&gt;
      </code></pre>
    </li>
  </ol>


  <h2 id="bootstrap4">Bootstrap 4</h2>

  <h3>1. Adding bootrap via 'ng-bootstrap' package </h3>
  <p>'ng-bootstrap' replaced jquery need with javascript code so dont need to include jQuery. </p>

  <p>1. install Bootstrap 4 and  'ng-bootstrap' package.</p>

  <pre><code class="language-bash">
    npm install bootstrap
    npm install --save @ng-bootstrap/ng-bootstrap
  </code></pre>

  <p>2. Need to inclue package and import into the @NgModule's import array</p>

  <pre><code class="language-bash">
    // app.module.ts
    import { NgbModule } from '@ng-bootstrap/ng-bootstrap';
    
    @NgModule({
      imports: [
        NgbModule.forRoot()
      ]
    })
  </code></pre>
    <p>3. Inclue bootstrap stylsheet in styles array in 'angular.json' file. </p>
    <pre><code class="language-js">
    "architect": {
      "build": {
        "options": {
          "styles": [
            "src/styles.scss",
            "./node_modules/bootstrap/scss/bootstrap.scss
            // "./node_modules/bootstrap/dist/css/bootstrap.css"
          ]
        }
      }
    }
  </code></pre>

  <p>3.1 or inclue bootstrap stylsheet in 'src/styles.scss' file. </p>
  <pre><code class="language-js">
    // if need customization
    @import "~bootstrap/scss/bootstrap";    
    // @import "./assets/styles/bootstrap_customizations.scss";
    // @import "./node_modules/bootstrap/scss/bootstrap.scss";
  </code></pre>
  
  <h3>2. Adding bootrap Using Schematics </h3> 
  <pre><code class="language-html">
    ng add @ng-bootstrap/schematics
  </code></pre>
  
  <h3>3. Adding bootrap via 'index.html' package </h3>  
  
  <pre><code class="language-html">
  &lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; integrity=&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot; crossorigin=&quot;anonymous&quot;&gt;
  &lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot; integrity=&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;
  </code></pre>

  <p class="note">'ngx-bootstrap' uses separate modules for components to reduce the final app size. But its a jquery dependent package.</p>

  <h2 id="materialUi">Material-UI</h2>

  <p>1. Use the Angular CLI's installation schematic to set up your Angular Material</p>
  <pre><code class="language-bash">
    ng add @angular/material
  </code></pre>

  <p>2. Include and import specific module. </p>
  <pre><code class="language-js">
    //src/app/app.module.ts
    import {MatButtonModule} from '@angular/material/button';
    @NgModule({
      imports: [ 
        MatButtonModule 
      ]
    })
  </code></pre>
</body>

</html>