<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>React</title>
  <link href="../../assets/prism.css" type="text/css" rel="stylesheet" media="all" />
  <link href="../../assets/styles.css" type="text/css" rel="stylesheet" media="all" />
  <script src="../../assets/prism.js"></script>
</head>

<body>
  <nav class="site-nav">
    <ul>
      <li><a href="#reactElement"></a></li>
    </ul>
  </nav>

  <p>Jest is a test framework developed by Facebook. </p>

  <p>Unlike its forerunners (notably Jasmine), which expect to run in a browser environment, Jest runs in a Node.js
    process. That may seem counterintuitive: Shouldn’t code written to be run in the browser be tested in the browser?
    Short answer: not anymore! It’s become possible to simulate browser APIs in Node.js, thanks to a miraculous library
    called jsdom.[6] The advantages of using a simulated browser environment in Node are huge: tests can be run much
    more quickly, code coverage can be calculated easily, and the same tests can be run on any system—whether it’s a
    developer’s laptop or a continuous integration server—with consistent results.</p>

  <h3>The Tao of Test-Driven Development</h3>
  <p>Test-driven development (TDD) is sometimes defined as writing tests first. Although that’s an important part of the
    methodology, it’s not the essence. The essence of TDD is rapid iteration. You’ll find that you learn more quickly
    from iterating—writing small, easy-to-understand pieces of code one at a time—than you would from trying to plan out
    a complex program from the ground up. You’ll discover bad assumptions and potential pitfalls before you invest too
    much work. And you’ll find the process more enjoyable, a smooth incremental progression rather than an alternation
    between bursts of inspiration and plateaus of “What do I do next?”</p>

  <h4>Mantra: Red, Green, Repeat</h4>
  <p>In the abstract, the act of writing tests before code may seem inconsequential. Writing code and writing tests are,
    one might imagine, two activities that can be done in any order with identical results. But imagining is one thing;
    hands-on experience is another. If you’ve done the exercise for this chapter, and taken advantage of Jest’s watch
    mode, then you know the feeling of satisfaction at watching a test flip from red to green as your code clicks into
    place.</p>
  <p>“Red, green, repeat” — encapsulates test-driven development (TDD) in a nutshell.</p>

  <pre><code class="language-js">
    ​​mkdir​​ test-driven-fizzbuzz
    cd​​ ​​test-driven-fizzbuzz/
    npm​​ init -y
    npm install --save-dev jest
    npx​​ ​​jest​​ ​​--version
  </code></pre>

  <p>Now Jest is installed and ready for you to use. However, it’s in the project’s node_modules, not on your PATH. To
    run it, you’ll need to call on another tool: npx.</p>

  <h3>RUNNING PACKAGE BINARIES WITH NPX</h3>
  <p>In 2017, the npm team introduced a sibling project: npx. Whereas npm is a package manager, npx is a package
    runner. Among other things, npx lets you run binaries from local Node packages without adding them to your PATH.</p>

  RUNNING PROJECT SCRIPTS WITH NPM
  <p>Replace the placeholder "test" script that npm init generated with jest</p>
  <pre><code class="language-js">
    "scripts"​: {
      ​"test"​: ​"jest"​
    }
  </code></pre>

  The test script is special to npm: You can execute it with either npm run test or just npm test.
  
  <h3>WRITING A TEST</h3>
  <p>Create a file called greeting.test.js:</p>
  <pre><code class="language-js">
  ​const greeting = guest => `Hello, ${guest}!`;

  describe('greeting()', () => {
      it('says hello', () => {
          expect(greeting('Jest')).toBe('Hello, Jest!');
      });
  });
  </code></pre>

  <p>run <code>npm​​ ​​run​​ ​​test​​ ​​--watchAll​​ ​​-- --coverage​​ ​​--coverageReporters=text</code></p>
  <p>run <code>npx​​ ​​prettier-eslint​​ ​​tests/palindromes.test.js</code></p>


  <ul>
    <li><code>describe()</code> declares a test suite, which is a grouping of tests. Its first argument is a name, and
      the second is
      a function containing one or more tests.</li>
    <li><code>it()</code> declares a test. Its first argument is a name, and the second is a function with the actual
      test code.
    </li>
    <li>​<code>expect()</code> creates an assertion. It takes a single argument, typically a value generated by the code
      being tested,
      and returns an object that exposes a set of matcher functions.

      <p><code>toBe()</code> is a matcher that performs a strict equality test between the value being tested (the
        <code>expect()</code> argument)
        and the expected value (its own argument).</p>
    </li>
  </ul>

  <p>Note the grammatical convention here: the test suite name ("greeting()") is a noun; the test name ("says hello") is
    a verb. Together, they form a complete sentence describing the functionality covered by the test ("greeting() says
    hello"). This convention helps make test output easy to read. You can learn more about all of these methods in the
    Jest API docs.[14]</p>
  <p>To run the test, all you need to do is invoke the jest CLI. By default, it finds and runs every file in the current
    project with the .test.js extension. Since you set jest as the test script in package.json, you can run it with npm
    run test:</p>

  <p>toBe() does a strict equality check, which would fail here. The toEqual() assertion method, by contrast, checks for
    deep object equality. So the assertion expect(x).toEqual([’madam’]) passes as long as x is an array with the string
    "madam" as its only entry.</p>


  <h3>Testing Simple Components with Enzyme</h3>
  <p>Create a new directory called <code>test-driven-carousel</code></p>


  <h2>Starting a React Project</h2>
  <pre><code class="language-js">
    mkdir test-driven-carousel
    cd test-driven-carousel
    npm init -y
    npm install --save-dev @babel/core
  </code></pre>
  <p>For this project, we’ll start with two popular Babel presets:</p>
  <ol>
    <li>The React preset which provides support for JSX.</li>
    <li>The env preset which provides support for all new JavaScript syntax features defined in ES2015 (a.k.a. ES6),
      ES2016, and ES2017. The name “env” refers to its ability to tailor the transpilation pipeline to a specified set
      of target environments.</li>
  </ol>
  <pre><code class="language-js">
    npm install --save-dev @babel/preset-react
    npm install --save-dev @babel/preset-env
  </code></pre>
  <p>Then bring in the two presets from a new file called .babelrc.js:</p>
  <pre><code class="language-js">
    // .babelrc.js​
    module.exports = {
        presets: ['@babel/preset-react', '@babel/preset-env'],
    };
  </code></pre>
  <p>Babel will now apply this configuration to every JS file in the project. To try it out, create a JS file called
    <strong>hello-babel.js:</strong></p>
  <pre><code class="language-js">
    // hello-babel.js​
    import figlet from 'figlet';
    console.log(figlet.textSync('Hello, Babel!'));
  </code></pre>
  <p>This file uses the ES2015 modules syntax in the form of the import keyword. If you try running it in Node without
    Babel, you’ll get a syntax error:</p>
  <pre><code class="language-js">
    node hello-babel.js //getting errors
  </code></pre>
  <pre><code class="language-js">
    npm install @babel/cli
  </code></pre>
  <p>@babel/cli includes an executable called babel that you can run with npx:</p>
  <pre><code class="language-js">
    npx babel hello-babel.js
  </code></pre>
  <p>You can run the compiled script by piping it into node. But first, install that package it’s trying to import:</p>
  <pre><code class="language-js">
    npm install figlet
  </code></pre>
  <pre><code class="language-js">
    npx babel hello-babel.js | node
  </code></pre>
  <p>Figlet took a plain old string and turned it into ASCII art.</p>

  <h3>Bridging Jest and Babel</h3>
  <p>In order to get Jest to run tests through Babel, you’ll need both jest and a package called babel-jest:</p>
  <pre><code class="language-js">
    npm install --save-dev jest 
    npm install --save-dev babel-jest
    npm install --save-dev @babel/core
  </code></pre>
  <p>Next, update the scripts entry in package.json to make Jest the project’s official test runner:</p>
  <pre><code class="language-js">
    "scripts": {
      "test": "jest"
    }
  </code></pre>
  You’ll also need the react-dom package, a bridge between React elements and the DOM, though only as a dev dependency
  for testing:
  <pre><code class="language-js">
    npm install react --save
    npm install react-dom --save
  </code></pre>
  <p>Create a test file that takes advantage of JSX and the ES2015 import syntax:</p>
  <pre><code class="language-js">
    // src/tests/hello.test.js​
    import React from 'react';

    describe('JSX', () =&gt; {
        it('calls React.createElement', () =&gt; {
            const createElementSpy = jest.spyOn(React, 'createElement');
            &lt;h1&gt;Hello, JSX!&lt;/h1&gt;;
            expect(createElementSpy).toHaveBeenCalledWith('h1', null, 'Hello, JSX!');
        });
    });
  </code></pre>
  <ol>
    <li><code class="language-js">jest.spyOn(React, "createElement")</code> replaces the <code
        class="language-js">React.createElement()</code> method with a spy that intercepts calls,
      allowing us to make assertions about how that method is used.
    </li>
    <li><code class="language-js">expect(spy).toHaveBeenCalledWith()</code> does just what it says on the tin, failing
      if the spy wasn’t called or was called with a different set of arguments.
    </li>
  </ol>
  <pre><code class="language-js">
    npx jest
  </code></pre>

  <h3>Adding Eslint and Prettier</h3>
  <pre><code class="language-js">
    npm install --save-dev eslint
    npm install --save-dev prettier-eslint-cli
    npm install --save-dev eslint-plugin-jest
  </code></pre>
  <p>Then add the scripts</p>
  <pre><code class="language-js">
    ​// package.json​
    "scripts": {
      "test": "jest",
      "lint": "eslint . && prettier-eslint --list-different **/*.js",
      "format": "prettier-eslint --write **/*.js"
    },
  </code></pre>
  <p>We’ll use three nested ESLint configurations for this project:</p>
  <ol>
    <li>The root configuration, .eslintrc.js</li>
    <li>The source configuration, src/.eslintrc.js</li>
    <li>The tests configuration, src/tests/.eslintrc.js</li>
  </ol>
  <p>The root and test configurations are :</p>
  <pre><code class="language-js">
  ​// .eslintrc.js​
  ​ 	module.exports = {
  ​ 	  extends: [​'eslint:recommended'​],
  ​ 	  parserOptions: {
  ​ 	    ecmaVersion: 6,
  ​ 	  },
  ​ 	  env: {
  ​ 	    "jest": true
  ​ 	  },
  ​ 	  rules: {
  ​ 	    quotes: [​'error'​, ​'single'​, { avoidEscape: ​true​ }],
  ​ 	    ​'comma-dangle'​: [​'error'​, ​'always-multiline'​],
  ​ 	  },
  ​ };
  </code></pre>
  <pre><code class="language-js">
  // tests/.eslintrc.js
  module.exports = {
    plugins: [​'jest'​],
    extends: [​'plugin:jest/recommended'​],
  };
  </code></pre>
  <p>The new configuration in src tells ESLint that our project’s code is intended for a browser environment:</p>
  <pre><code class="language-js">
    // src/.eslintrc.js
    module.exports = {
      env: {
          browser: true,
      },
    };
  </code></pre>
  <pre><code class="language-js">
    npx eslint src/tests/hello.test.js
  </code></pre>

  <p>The error indicates that ESLint is aware of the import syntax but isn’t sure if this JS file is supposed to be an
    ES2015 module. . To get ESLint to recognize them as such, modify the parserOptions in the root ESLint config:</p>
  ​
  <pre><code class="language-js">
  // .eslintrc.js​
  module.exports = {
    parserOptions: {
        ecmaVersion: 6,
        sourceType: ​'module'​,
    }
  };
  </code></pre>
  <ol>
    <li>sourceType: ’module’ tells ESLint that our code will run in an environment that supports the ES2015 (a.k.a. ES6)
      import/export syntax.</li>
  </ol>
  <p>Try running the linter again:</p>

  <pre><code class="language-js">
    npx eslint src/tests/hello.test.js
  </code></pre>

  <p>Now ESLint is saying that it doesn’t recognize JSX syntax. This, too, is best solved through parserOptions:</p>
  <pre><code class="language-js">
    // .eslintrc.js​
    module.exports = {
      parserOptions: {
          ecmaVersion: 6,
          sourceType: 'module',
          ecmaFeatures: {
              jsx: true
          },
      },
    };
  </code></pre>

  <p>One more attempt:</p>

  <pre><code class="language-js">
    npx eslint src/tests/hello.test.js
  </code></pre>

  <p>Since you’ll be using React in your tests, it’s a good idea to make the linter aware of it. To do that, you’ll need
    another plugin, eslint-plugin-react:
  </p>
  <pre><code class="language-js">
    npm install --save-dev eslint-plugin-react
  </code></pre>

  <p>Apply the plugin by adding it to the plugins section of your ESLint config, then add its recommended set of rules
    to our extends list. This plugin is relevant to app code as well as tests, so it belongs in the root ESLint config:
  </p>
  <pre><code class="language-js">
    // .eslintrc.js​
    module.exports = {
      plugins: ['react'],
      extends: ['eslint:recommended', 'plugin:react/recommended']
    };
  </code></pre>
  <p>Additionally, eslint-plugin-react can make suggestions targeted to the React version you’re using if you specify it
    in a settings block:
  </p>
  <pre><code class="language-js">
    // .eslintrc.js​
    module.exports = {
      settings: {
          react: {
              version: '16.12.0'
          }
      }
    };
    </code></pre>

  <h3>Configuring Wallaby for Babel</h3>
  <p>Create a new wallaby.js file in the root of the project:</p>

  <pre><code class="language-js">
    //wallaby.js
    module.exports = function (wallaby) {
        return {
            testFramework: 'jest',
            env: {
                type: 'node',
            },
            tests: ['src/tests/**/*.test.js'],
            files: ['src/**/*.js', '!**/*.test.js', '!**/.*'],
            compilers: {
                '**/*.js': wallaby.compilers.babel(),
            },
        };
    };
  </code></pre>
  <ol>
    <li>The compilers entry tells Wallaby that all .js files should be compiled with Babel.</li>
  </ol>
  <p>Run the Wallaby.js: Start command. Give it a minute to spin up, and watch as hello.test.js is bedecked in beautiful
    green annotations.</p>
  <pre><code class="language-js">
    Wallaby.js: Start
  </code></pre>

  <h2>Testing Simple Components with Enzyme</h2>
  <p>we’re going to build a carousel.</p>

  <p>Enzyme is especially good at rendering a single component in isolation, a technique known as “shallow rendering,”
    and letting you see how changes in the component’s props and state cause its render tree to change. With shallow
    rendering, other components in the render tree are treated as black boxes: you can see what props they receive, but
    not their output. We’ll be using shallow rendering for all of the React component tests</p>

  <h3>Enzyme vs. react-testing-library</h3>

  <p>Enzyme is a Swiss Army knife for testing React components, react-testing-library is focused on a single approach:
    rendering components to the DOM and making assertions about that DOM tree.</p>

  <p>Testing individual components in isolation, which isn’t possible with react-testing-library. However,
    react-testing-library’s approach is more conceptually straightforward. Furthermore, Enzyme’s development has lagged
    somewhat; as of this writing, its shallow rendering mode lacks support for some cutting-edge React features, such as
    the new context API introduced in React 16.3.</p>

  <p>You’ll need to install Enzyme, plus the “adapter” that lets it plug into the version of React you’re using:</p>
  <pre><code class="language-js">
    npm install --save-dev enzyme
    npm install --save-dev enzyme enzyme-adapter-react-16
  </code></pre>

  <pre><code class="language-js">
    import React from 'react';

    const CarouselButton = () =&gt; &lt;button /&gt;;

    export default CarouselButton;
  </code></pre>
</body>

</html>